diff '--color=auto' -r main/.git refactor/.git
1c1
< gitdir: /home/nn/src/git/hub/.git/worktrees/main
---
> gitdir: /home/nn/src/git/hub/.git/worktrees/refactor
diff '--color=auto' -r main/.gitignore refactor/.gitignore
1,6c1,2
< depends.mk
< bin/markout
< **.d
< **.[os]
< **.ii
< **.a
---
> **.[ioSd][ioSd]
> **.[d]
9,10d4
< bin/report
< bin/string_view
18,19d11
< ,/bin/lspath
< bin/lspath
21a14,15
> *.a
> hide
Only in refactor: 1ea
diff '--color=auto' -r main/Makefile refactor/Makefile
1,2d0
< MAKEFLAGS:= -rR -j24
< .EXPORT_ALL_VARIABLED:
4d1
< define dir_infer
6,16c3
< $1/src:=  $(wildcard  $1/*.cc)                         
< $1/exe:=  $(patsubst  %.cc,%,   $($1/src))             
< $1/asm:=  $(wildcard  $1/*.S)                          
< $1/xxx:=  $(patsubst  %,%.o,   $($1/asm))             
< $1/exe+=  $(patsubst  %,%,      $($1/asm))             
< $1/obj:=  $(patsubst  %,%.o,   $($1/src))             
< $1/cpp:=  $(patsubst  %,%.ii,   $($1/src))             
< $1/dep:=  $(patsubst  %,%.d,    $($1/obj)   $($1/cpp)  $($1/asm))
< $1:=$($1/exe)
< endef
< $(call dir_infir,bin,lib) 
---
> include etc/sub-dir.mk
18,22c5,6
< all/obj:= $(lib/obj) $(bin/obj)
< all/xxx:= $(lib/xxx) $(bin/xxx)
< all/cpp:= $(lib/cpp) $(bin/cpp)
< all/src:= $(lib/src) $(bin/src)
< all/dep:= $(lib/dep) $(bin/dep)
---
> #$(warning libs: $(all/lib))
> all: $(all/lib)
24c8,9
< include /dev/null $(wildcard $(all/dep))
---
> #$(warning exes: $(all/exe))
> all: $(all/exe)
26,27d10
< ext/obj:= $(filter-out $(all/obj), $(wildcard *.o))
< ext/xxx:= $(filter-out $(all/xxx), $(wildcard *.o))
29,33d11
< all:= $(bin/exe) $(lib/lib)
< bin:= $(bin/exe)
< lib:= $(lib/lib)
< $(bin): $(lib)
< all: $(all)
35d12
< include /dev/null $(wildcard $(all/dep))
37,77d13
< $(lib/lib): $(lib/obj) $(lib/xxx)
< 	sbin/arch "$@" $(lib/obj) $(lib/xxx)
< 
< $(bin/exe): %: %.o sbin/link etc/ld_flags
< 	sbin/link "$@" $(lib/lib)
< 
< $(all/cpp): %.ii: %.cc sbin/prec etc/cppflags
< 	rm -f $*.ii $*.o
< 	sbin/prec "$@"
< 
< $(all/xxx): %.o: %.S sbin/casm etc/asmflags
< 	sbin/casm "$@"
< 
< $(all/obj): %.o: %.ii sbin/comp etc/cxxflags
< 	sbin/comp "$@"
< 
< cur/dep:=$(wildcard *.o.d)
< cur/obj:=$(wildcard *.o) $(patsubst %.d,%,$(cur/dep))
< cur/src:=$(patsubst %.o,%.cc,$(cur/obj))
< 
< 
< ifneq ($(have),$(want))
< $(lib/lib): rem-lib
< endif
< 
< ###   
< clean: date:=$(shell serdate)
< 
< clean:
< 	rm -f */*.[ioad]
< 
< $(all/obj): sbin/comp
< $(bin/exe): sbin/link
< $(lib/lib): sbin/arch
< $(bin/exe): $(lib)
< 
< tags: */*.cc */*.hh
< 	ctags --language-force=c++ */*.cc */*.hh
< 
< nm:
< 	nm */*.a */*.o --defined-only -A --demangle
diff '--color=auto' -r main/bin/.gitignore refactor/bin/.gitignore
9,15c9
< not
< cat
< echo
< false
< ls
< lspath
< not
---
> printenv
16a11
> runrep
18,20c13
< test_getopt
< true
< usleep
---
> touch
diff '--color=auto' -r main/bin/cat.cc refactor/bin/cat.cc
4c4
< 
---
> using sys::exit;
51a52,93
> extern "C" {
>   int main(int argc, char**argv,char **envp);
> };
> template<typename val_t>
> struct vector
> {
>   val_t *arr;
>   size_t len;
>   vector()
>     : arr(nullptr), len(0)
>   {
>   };
>   vector(val_t *beg, val_t *end)
>     : arr(beg), len(end-beg)
>   {
>   };
>   val_t &operator[](size_t n)
>   {
>     assert(n<size());
>     return arr[n];
>   };
>   const val_t &operator[](size_t n) const
>   {
>     assert(n<size());
>     return arr[n];
>   };
>   size_t size() const {
>     return  len;
>   };
>   const val_t *begin() const {
>     return arr;
>   };
>   const val_t *end() const {
>     return arr+len;
>   };
>   val_t *begin() {
>     return arr;
>   };
>   val_t *end() {
>     return arr+len;
>   };
> };
85a128,134
>     write(1,"c=");
>     write_dec(1,c);
>     write(1," argc=");
>     write_dec(1,argc);
>     write(1," optind=");
>     write_dec(1,optind);
>     write(1,"\n");
139c188
<         write(2,"open:");
---
>         write(2,"open:",5);
Only in main/bin: echo.cc
Only in main/bin: false.S
Only in refactor/bin: false.SS
diff '--color=auto' -r main/bin/ls.cc refactor/bin/ls.cc
10c10
< void swap(obj_t &lhs, obj_t &rhs)
---
> void swap(obj_t &lhs, obj_t rhs)
15a16,80
> struct dirents_t {
>   struct ent_t {
>     bool dir;
>     char name[256];
>     ent_t()
>       :dir(false)
>     {
>     };
>     ent_t(const char *_name, bool _dir)
>       :dir(_dir)
>     {
>       strncpy(name,_name,sizeof(name));
>     };
>   };
>   size_t cap;
>   size_t cnt;
>   ent_t **lst;
>   dirents_t()
>     : lst(0), cap(0), cnt(0)
>   {
>   };
>   int cmp(ent_t &lhs, ent_t&rhs) {
>     return strcmp(rhs.name,lhs.name);
>   };
>   void sort() {
>     size_t n=size();
>     for(int i=0;i<n-2;i++) {
>       int m=i;
>       for(int j=i+1;j<n;j++) {
>         if(cmp(*lst[m],*lst[j])<0)
>           m=j;
>       };
>       if(i!=m)
>         swap(lst[i],lst[m]);
>     };
>   };
>   ~dirents_t() {
>     for(int i=0;i<cnt;i++)
>       delete lst[i];
>     delete[] lst;
>   };
>   void push_back(const char *name, bool isdir)
>   {
>     if(cnt==cap) {
>       if(cap) {
>         ent_t **nlst = new ent_t*[cap+16];
>         memcpy(nlst,lst,sizeof(ent_t*)*cap);
>         delete[] lst;
>         lst=nlst;
>       } else {
>         lst = new ent_t*[16];
>       };
>       cap+=16;
>     };
>     ent_t *new_ent=new ent_t(name,isdir);
>     lst[cnt++]=new_ent;
>   };
>   ent_t &get(size_t pos)
>   {
>     return *lst[pos];
>   };
>   size_t size() const {
>     return cnt;
>   };
> };
24d88
< bool dotfiles=false;
28,68d91
< 
< int sign(int lhs){
<   if(lhs<0)
<     return -1;
<   else if (lhs>0)
<     return 1;
<   else
<     return 0;
< };
< int cmp(const char *lhs, const char *rhs){
<   while(*lhs == *rhs && *lhs)
<     ++lhs, ++rhs;
<   return sign(*lhs-*rhs);
< };
< void sort(linux_dirent **beg, linux_dirent**end)
< {
<   if(beg==end)
<     return;
<   linux_dirent** pos=beg;
<   while(pos<end){
<     while(++beg<end){
<       if(cmp((*beg)->d_name,(*pos)->d_name)<0)
<         swap(*beg,*pos);
<     }
<     pos++;
<     beg=pos;
<   }
< };
< bool skip(const char *name){
<   if(name[0]!='.')
<     return false;
<   if(ignore==normal)
<     return true;
<   if(ignore==minimal)
<     return false;
<   if(name[1]==0)
<     return true;
<   if(name[1]=='.' && name[2]==0)
<     return true;
<   return false;
< };
70,71d92
<   int n=0;
<   linux_dirent*ents[8192];
72a94
>   dirents_t ents;
82,85c104,105
<     while(beg!=end){
<       if(!skip(beg->d_name)){
<         ents[n++]=beg;
<       };
---
>     while(beg!=end) {
>       ents.push_back(beg->d_name,beg->d_type == DT_DIR);
87c107,108
<     }
---
>     };
>     //mm_show();
89,92c110,124
<   sort(ents,ents+n);
<   for(int i=0;i<n;i++){
<     write(1,ents[i]->d_name);
<     write(1,"\n");
---
>   ents.sort();
>   for(size_t i=0;i<ents.size();i++)
>   {
>     auto ent=ents.get(i);
>     if(ignore==dot_dot) {
>       if(!strcmp(ent.name,"."))
>         continue;
>       if(!strcmp(ent.name,".."))
>         continue;
>     } else if ( ignore != minimal ) {
>       if(ent.name[0]=='.')
>         continue;
>     };
>     write(1,ent.name);
>     write(1,L("\n"));
150a183,185
> extern "C" {
>   int main(int argc, char**argv, char**envp) ;
> };
161d195
<   using fmt::write_dec;
Only in main/bin: lspath.cc
Only in main/bin: not.cc
Only in refactor/bin: printenv.cc
diff '--color=auto' -r main/bin/report.cc refactor/bin/report.cc
1,61c1,63
< #include<syscall.hh>
< 
< //   #define wifexited(res) (wtermsig(res)==0)
< //   #define wtermsig(res) (res&0x7f)
< //   #define wexitstatus(res) ((res&0xff00)>>8)
< //   
< //   
< //   typedef char * str_t;
< //   typedef const char *str_c;
< //   
< //   int main(int argc, char** argv, char **envp)
< //   {
< //     if(argc<2) {
< //       write(2,"usage: ");
< //       write(2,argv[0]);
< //       write(2," <command>\n");
< //       return 2;
< //     };
< //     pid_t opid=sys::getpid();
< //     pid_t npid=xfork();
< //     int res;
< //     if(npid) {
< //       if(sys::wait(&res)<0){
< //         write(2,"wait: ");
< //         write(2,sys::strerror(sys::errno));
< //         write(2,"\n");
< //         return 1;
< //       };
< //   
< //       auto pos=argv;
< //       if(pos){
< //         if(*pos){
< //           write(2,*pos);
< //           while(*++pos){
< //             write(2," ");
< //             write(2,*pos);
< //           };
< //           write(2," returned ");
< //           write_dec(2,res);
< //           write(2,"\n");
< //           exit(res);
< //         };
< //       };
< //       if( wifexited(res) ) {
< //         res=wexitstatus(res);
< //         write(2,"returned ");
< //         write_dec(2,res);
< //         write(2,"\n");
< //         exit(res);
< //       } else {
< //         write(2,"sig: ");
< //         write_dec(2,wtermsig(res));
< //         write(2,"\n\n");
< //       };
< //     } else {
< //       ++argv;
< //       sys::execve(argv[0],argv, envp);
< //       return 0;
< //     };
< //     return res;
< //   };
---
> #include <syscall.hh>
> #include <search_path.hh>
> using shell_ns::search_path;
> using namespace sys;
> char **envp;
> template<typename val_t>
> void fmt(fd_t fd, val_t val);
> template<>
> void fmt<int>(fd_t fd, int val)
> {
>   static char buf[]="xxxxxxxxxxxxxxxx";
>   char *end=buf+sizeof(buf)-1;
>   if(val) {
>     while(val) {
>       *--end=(val%10)+'0';
>       val/=10;
>     };
>   } else {
>     *--end='0';
>   };
>   write(2,end);
> };
> extern istr_t *environ;
> template<>
> void fmt<const char*>(fd_t fd, const char * val)
> {
>   write(fd,val);
> }
> static char full[16*1024];
> using shell_ns::search_path;
> int main(int argc, char**argv, char**envp){
>   char *path=0;
>   bool abs=true;
>   if(!argv[1]) {
>     write(2,"No program provided\n");
>     exit(2);
>   };
>   const char *full=0;
>   full=search_path(argv[1],"PATH",false);
>   if(!full) {
>     write(2,"not found\n");
>     exit(97);
>   };
>   argv++;
>   pid_t pid=fork();
>   pid_t res;
>   if(pid) {
>     int ret;
>     do {
>       res=waitpid(0,&ret,0);
>       fmt(2,"pid ");
>       fmt(2,res);
>       fmt(2,"  returned ");
>       fmt(2,ret);
>       exit(ret/256);
>     } while(res>0);
>   } else {
>     execve(argv[0],argv,envp);
>     write(2,"execve:argv[0]");
>     exit(1);
>   }
>   return 0;
> };
Only in refactor/bin: runrep.cc
diff '--color=auto' -r main/bin/string_view.cc refactor/bin/string_view.cc
2a3,4
> extern "C" int main(int, char**);
> 
Only in main/bin: test_getopt.cc
Only in refactor/bin: touch.cc
Only in refactor/bin: touch.help.inl
Only in main/bin: true.S
Only in refactor/bin: true.SS
diff '--color=auto' -r main/bin/usleep.cc refactor/bin/usleep.cc
7a8
> using sys::exit;
Only in main/: breakpoints
Only in main/: depends.pl
Only in refactor/doc: gentest.pl
Only in refactor/doc: git-log.txt
Only in main/doc: lspath.bash
Only in refactor/doc: touch.help
diff '--color=auto' -r main/etc/asmflags refactor/etc/asmflags
0a1
> -g -O0
Only in refactor/etc: bin-dir.mk
diff '--color=auto' -r main/etc/cppflags refactor/etc/cppflags
2d1
< 
4a4,7
> -ffreestanding
> -fno-exceptions
> -ggdb3 -O0
> -fno-stack-protector
diff '--color=auto' -r main/etc/cxxflags refactor/etc/cxxflags
3,4c3
< -ggdb3
< -O0
---
> -ggdb3 -O0
Only in refactor/etc: init.mk
diff '--color=auto' -r main/etc/ld_flags refactor/etc/ld_flags
1,2d0
< --freestanding
< -Bdynamic
4a3
> -Wl,--verbose
8c7
< -ggdb3 -O0
---
> -ggdb3
Only in refactor/etc: lib-dir.mk
Only in refactor/etc: makflags
Only in refactor/etc: resolve.mk
Only in refactor/etc: rules.mk
Only in refactor/etc: sub-dir.mk
Only in main/: files.md5
Only in refactor/inc: all-syscall.hh
Only in refactor/inc: assert.h
Only in refactor/inc: attrs.hh
diff '--color=auto' -r main/inc/buf.hh refactor/inc/buf.hh
4a5
> #include <fmt.hh>
10c11,13
<     buf_t()
---
>     int fd;
>     buf_t(int fd=1)
>       :fd(fd)
16c19
<       sys::write(1,text,len);
---
>       sys::write(fd,text,len);
diff '--color=auto' -r main/inc/c_str.hh refactor/inc/c_str.hh
111c111
<   return sys::write(fd, str.begin(), str.size());
---
>   return sys::sys_write(fd, str.begin(), str.size());
diff '--color=auto' -r main/inc/errno.hh refactor/inc/errno.hh
1,54c1
< #ifndef errno_hh
< #define errno_hh errno_hh
< 
< #include <types.hh>
< 
< #define	EPERM		 1	/* Operation not permitted */
< #define	ENOENT		 2	/* No such file or directory */
< #define	ESRCH		 3	/* No such process */
< #define	EINTR		 4	/* Interrupted system call */
< #define	EIO		 5	/* I/O error */
< #define	ENXIO		 6	/* No such device or address */
< #define	E2BIG		 7	/* Argument list too long */
< #define	ENOEXEC		 8	/* Exec format error */
< #define	EBADF		 9	/* Bad file number */
< #define	ECHILD		10	/* No child processes */
< #define	EAGAIN		11	/* Try again */
< #define	ENOMEM		12	/* Out of memory */
< #define	EACCES		13	/* Permission denied */
< #define	EFAULT		14	/* Bad address */
< #define	ENOTBLK		15	/* Block device required */
< #define	EBUSY		16	/* Device or resource busy */
< #define	EEXIST		17	/* File exists */
< #define	EXDEV		18	/* Cross-device link */
< #define	ENODEV		19	/* No such device */
< #define	ENOTDIR		20	/* Not a directory */
< #define	EISDIR		21	/* Is a directory */
< #define	EINVAL		22	/* Invalid argument */
< #define	ENFILE		23	/* File table overflow */
< #define	EMFILE		24	/* Too many open files */
< #define	ENOTTY		25	/* Not a typewriter */
< #define	ETXTBSY		26	/* Text file busy */
< #define	EFBIG		27	/* File too large */
< #define	ENOSPC		28	/* No space left on device */
< #define	ESPIPE		29	/* Illegal seek */
< #define	EROFS		30	/* Read-only file system */
< #define	EMLINK		31	/* Too many links */
< #define	EPIPE		32	/* Broken pipe */
< #define	EDOM		33	/* Math argument out of domain of func */
< #define	ERANGE		34	/* Math result not representable */
< 
< 
< struct c_str;
< namespace sys {
<   typedef long errno_t;
<   extern errno_t errno;
<   ssize_t set_errno(errno_t err);
<   const c_str &strerror(errno_t err=errno);
<   void perror(const c_str &msg1, const c_str &msg2);
<   void pexit(const c_str &msg1, const c_str &msg2);
<   void perror(const c_str &msg1);
<   void pexit(const c_str &msg1);
< };
< 
< #endif
---
> #include <linux/errno.hh>
Only in refactor/inc: error_t.hh
diff '--color=auto' -r main/inc/fmt.hh refactor/inc/fmt.hh
7c7
< #define AAI __attribute__((__always_inline__))
---
> #define AIL __attribute__((__always_inline__))
9c9
< #define AAI
---
> #define AIL
35c35
<   inline char *fmt_ptr(void *val, char *beg, char *end) {
---
>   inline char *fmt_ptr(const void *val, char *beg, char *end) {
53,54d52
<     if(neg)
<       *--end = '-';
61c59
<   inline int write_dec(fd_t fd, int val) {
---
>   inline int write_dec(fd_t fd, size_t val) {
63c61
<     return write(fd, fmt::fmt_dec(val<0,val<0?-val:val, buf, &buf[sizeof(buf) - 1]));
---
>     return write(fd, fmt::fmt_dec(false,val, buf, &buf[sizeof(buf) - 1]));
69c67
<   inline int write_ptr(fd_t fd, void *ptr) {
---
>   inline int write_ptr(fd_t fd, const void *ptr) {
71c69
<     return write(fd, fmt::fmt_ptr((void *)ptr, buf, &buf[sizeof(buf) - 1]));
---
>     return write(fd, fmt::fmt_ptr((const void *)ptr, buf, &buf[sizeof(buf) - 1]));
115c113
<           exit(1);
---
>           sys::exit(1);
119a118,137
> #define show_val(x) do_show_val(L(#x),(x))
> #define show_dec(x)                                                            \
>   do {                                                                         \
>     write(2, L(#x " => "));                                                    \
>     write_dec(2, (x));                                                         \
>     write(2, L("\n"));                                                         \
>   } while (false);
> #define show_ptr(x)                                                            \
>   do {                                                                         \
>     write(2, L(#x " => "));                                                    \
>     write_ptr(2, (x));                                                         \
>     write(2, L("\n"));                                                         \
>   } while (false);
> #define show_hex(x)                                                            \
>   do {                                                                         \
>     write(2, L(#x " => "));                                                    \
>     write_hex(2, (x));                                                         \
>     write(2, L("\n"));                                                         \
>   } while (false);
> #undef AAI
165c183
<     int fmt(void *vp)
---
>     int fmt(const void *vp)
diff '--color=auto' -r main/inc/getopt.hh refactor/inc/getopt.hh
1,2c1,34
< #ifndef GETOPT_HH
< #define GETOPT_HH GETOPT_HH
---
> /*******************************************************************************
>  * Copyright (c) 2012-2017, Kim Grasman <kim.grasman@gmail.com>
>  * All rights reserved.
>  *
>  * Redistribution and use in source and binary forms, with or without
>  * modification, are permitted provided that the following conditions are met:
>  *   * Redistributions of source code must retain the above copyright
>  *     notice, this list of conditions and the following disclaimer.
>  *   * Redistributions in binary form must reproduce the above copyright
>  *     notice, this list of conditions and the following disclaimer in the
>  *     documentation and/or other materials provided with the distribution.
>  *   * Neither the name of Kim Grasman nor the
>  *     names of contributors may be used to endorse or promote products
>  *     derived from this software without specific prior written permission.
>  *
>  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
>  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
>  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
>  * ARE DISCLAIMED. IN NO EVENT SHALL KIM GRASMAN BE LIABLE FOR ANY
>  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
>  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
>  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
>  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
>  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
>  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
>  *
>  ******************************************************************************/
> 
> #ifndef INCLUDED_GETOPT_PORT_H
> #define INCLUDED_GETOPT_PORT_H
> 
> #if defined(__cplusplus)
> extern "C" {
> #endif
22a55,57
> #if defined(__cplusplus)
> }
> #endif
Only in refactor/inc: ioflags.hh
Only in refactor/inc: linux
Only in main/inc: ostream.hh
Only in refactor/inc: search_path.hh
diff '--color=auto' -r main/inc/stdlib.hh refactor/inc/stdlib.hh
7,20c7,20
<   void*         malloc(size_t);
<   void          free(void*);
<   void*         realloc(void* ptr, size_t size);
<   inline void*  sbrk(intptr_t increment) AAI;
<   inline int    strcmp(const char* s1, const char* s2) AAI;
<   inline void*  memset(void* s, int c, size_t n) AAI;
<   inline void*  memcpy(void* dst, const void* src, size_t n) AAI;
<   inline int    memcmp(const void* dst, const void* src, size_t n) AAI;
<   inline void*  memmove(void* dst, const void* src, size_t n) AAI;
<   inline void*  memchr(const void* _mem, int c, size_t n) AAI;
<   inline char*  strcpy(char* d, const char* s) AAI;
<   inline char*  strncpy(char* dst, const char* src, size_t n) AAI;
<   inline char*  strncpy(char* dst, const char* src, size_t n) AAI;
<   inline size_t strlen(const char* s) AAI;
---
>   extern void*  malloc(size_t);
>   extern void   free(void*);
>   extern void*  realloc(void* ptr, size_t size);
>   inline void*  sbrk(intptr_t increment) AIL;
>   inline int    strcmp(const char* s1, const char* s2) AIL;
>   inline void*  memset(void* s, int c, size_t n) AIL;
>   inline void*  memcpy(void* dst, const void* src, size_t n) AIL;
>   inline int    memcmp(const void* dst, const void* src, size_t n) AIL;
>   inline void*  memmove(void* dst, const void* src, size_t n) AIL;
>   inline void*  memchr(const void* _mem, int c, size_t n) AIL;
>   inline char*  strcpy(char* d, const char* s) AIL;
>   inline char*  strncpy(char* dst, const char* src, size_t n) AIL;
>   inline char*  strncpy(char* dst, const char* src, size_t n) AIL;
>   inline size_t strlen(const char* s) AIL;
31d30
<   void         exit(int res);
diff '--color=auto' -r main/inc/syscall.hh refactor/inc/syscall.hh
1,544c1
< #ifndef syscall_hh
< #define syscall_hh syscall_hh
< 
< #include <errno.hh>
< #include <types.hh>
< 
< #if 1
< #define AAI __attribute__((__always_inline__))
< #define NOR  __attribute__((__noreturn__))
< #else
< #define AAI
< #endif
< 
< namespace sys
< {
< #define linux_dirent64 linux_dirent
<   enum open_mode
<   {
<     o_default= 0664
<   };
<   enum open_flags
<   {
<     o_rdonly   = 0000,
<     o_wronly   = 0001,
<     o_rdwr     = 0002,
<     o_mask     = 0003,
<     o_creat    = 00000100,
<     o_excl     = 00000200,
<     o_noctty   = 00000400,
<     o_trunc    = 00001000,
<     o_append   = 00002000,
<     o_nonblock = 00004000,
<     o_dsync    = 00010000,
<     o_fasync   = 00020000,
<     o_direct   = 00040000,
<     o_largefile= 00100000,
<     o_directory= 00200000,
<     o_nofollow = 00400000,
<     o_noatime  = 01000000,
<     o_cloexec  = 02000000,
<   };
<   inline open_flags operator|(open_flags lhs, open_flags rhs)
<   {
<     return open_flags(int(lhs) | int(rhs));
<   }
<   inline open_flags operator&(open_flags lhs, open_flags rhs)
<   {
<     return open_flags(int(lhs) & int(rhs));
<   }
< } // namespace sys
< 
< #include <stdlib.hh>
< #define chk_return2(val, cast)                                            \
<   return (cast)(val < 0 ? set_errno(val) : val)
< #define chk_return(val) return set_errno(val);
< namespace sys
< {
<   extern "C"
<   {
<     inline int     nanosleep(timespec_p rqtp, timespec_p rmtp) AAI;
<     inline int     close(fd_t fd) AAI;
<     inline int     stat(const char* pathname, struct stat* statbuf) AAI;
<     inline fd_t    open(const char* pathname, open_flags  flags, open_mode   mode) AAI;
<     inline time_t  time(time_t*) AAI;
<     inline ssize_t getdents(fd_t fd, linux_dirent64* buf, size_t len) AAI;
<     inline ssize_t read(fd_t fd, char* buf, size_t len) AAI;
<     inline ssize_t write(fd_t fd, const char* buf, size_t len) AAI;
<   }
<   inline void    exit(int res) NOR;
< 
<   // __NR_read=0
<   inline ssize_t read(fd_t fd, char* buf, size_t len)
<   {
<     long res;
<     asm("syscall"
<         : "=a"(res)
<         : "a"(0), "D"(fd), "S"(buf), "d"(len)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR_write=1
<   inline ssize_t write(fd_t fd, const char* buf, size_t len)
<   {
<     long res;
<     if(!buf) {
<       buf="<null>";
<       len=6;
<     };
<     asm("syscall\n"
<         : "=a"(res)
<         : "a"(1), "D"(fd), "S"(buf), "d"(len)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR_open=2
<   inline fd_t open(const char* pathname,
<                    open_flags  flags,
<                    open_mode   mode= o_default)
<   {
<     int fd= -1;
<     asm("syscall\n"
<         : "=a"(fd)
<         : "0"(2), "D"(pathname), "S"(flags), "d"(mode)
<         : "rcx", "r11", "memory");
<     chk_return(fd);
<   }
<   // __NR_close=3
<   inline int close(fd_t fd)
<   {
<     asm("syscall\n"
<         : "=a"(fd) 
<         : "0"(3), "D"(fd) 
<         : "rcx", "r11", "memory");
<     chk_return(fd);
<   }
<   // __NR_stat=4
<   inline int stat(const char* pathname, struct stat* statbuf)
<   {
<     int res= -1;
<     asm("syscall\n"
<         : "=a"(res)
<         : "a"(4), "D"(pathname), "S"(statbuf)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR__ lseek = 8
<   // inline int lseek(fd_t fd, off_t offset, unsigned origin)
<   enum origin_t
<   {
<     set= 0,
<     cur= 1,
<     end= 2
<   };
<   inline off_t lseek(fd_t fd, off_t off, origin_t origin)
<   {
<     off_t res;
<     asm("syscall\n"
<         : "=a"(res)
<         : "0"(8), "D"(fd), "S"(off), "d"(origin)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
< 
< 
<   enum mmap_prot_t
<   {
<     // For MMAP.
<     prot_none = 0x0,
<     prot_read = 0x1,
<     prot_write= 0x2,
<     prot_exec = 0x4,
<   };
< 
< 
<   enum mmap_flag_t
<   {
<     map_private  = 0x02,
<     map_shared   = 0x01,
<     map_fixed    = 0x10,
<     map_anon     = 0x20,
<     map_anonymous= map_anon,
<     map_growsdown= 0x00100,
<     map_noreserve= 0x04000,
<     map_nonblock = 0x10000,
<     map_populate = 0x08000,
<     map_stack    = 0x20000,
<   };
<   // __NR_mmap=9
<   inline char* mmap(void*  addr,
<                     size_t length,
<                     int    prot,
<                     int    flags,
<                     fd_t   fd,
<                     off_t  off)
<   {
< 
<     uint64_t res;
< 
<     __asm__ volatile(
<              "\tmovq %5,%%r10 ;\n"
<              "\tmovq %6,%%r8 ;\n"
<              "\tmovq %7, %%r9; \n"
<              "\tsyscall;\n"
<              : "=a"(res)
<              : "0"(9),
<                "D"(addr),
<                "S"(length),
<                "d"(prot),
<                "g"(flags),
<                "g"(long(fd)),
<                "g"(long(off))
<              : "r11", "rcx", "memory", "r10", "r8", "r9");
< 
<     chk_return2(res, char*);
<   }
<   // __NR_sigaction = 13
<   inline int rt_sigaction(int sig, sigaction_p act, sigaction_p oact)
<   {
< 
<     uint64_t res;
< 
<     asm("\tmovq %5,%%r10 ;\n"
<         "\tsyscall;\n"
<         : "=a"(res)
<         : "0"(13), "D"(sig), "S"(act), "d"(oact), "g"(sizeof(sigset_t))
<         : "r11", "rcx", "memory");
< 
<     chk_return(res);
<   }
<   // __NR_sigprocmask=14
<   inline int rt_sigprocmask(int how, sigset_p nset, sigset_p oset)
<   {
<     int res= -1;
<     asm("\tmovq %5,%%r10 ;\n"
<         "\tsyscall;\n"
<         : "=a"(res)
<         : "0"(14), "D"(how), "S"(nset), "d"(oset), "g"(sizeof(sigset_t))
<         : "r11", "rcx", "memory");
< 
<     chk_return(res);
<   }
<   // __NR_sigreturn=15
<   inline void rt_sigreturn()
<   {
<     int res= -1;
<     asm("syscall\n" : "=a"(res) : "0"(15) : "rcx", "r11", "memory");
<     if(res < 0)
<       set_errno(res);
<   }
<   // __NR__ pipe = 22 
< 
<   inline int pipe(fd_p fds)
<   {
<     time_t res= -1;
<     asm("syscall\n"
<         : "=a"(res)
<         : "a"(22), "D"(fds)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   //     }
<   //     inline char *mmap(
<   //         void *addr, size_t length, int prot, int flags, fd_t fd, off_t
<   //         off
<   //         )
<   // __NR__ select = 23
<   inline int select(int       n,
<                     fd_set_p  inp,
<                     fd_set_p  outp,
<                     fd_set_p  exp,
<                     timeval_p tvp= 0)
<   {
< 
<     uint64_t res;
< 
<     __asm__ volatile(
<              "\tsyscall;\n"
<              : "=a"(res)
<              : "0"(23), "D"(n), "S"(inp), "d"(outp), "g"(exp), "g"(tvp)
<              : "rcx", "memory", "r8", "r9");
< 
<     chk_return(res);
<   }
< 
<   // __NR_dup = 32
<   inline int dup(fd_t fd)
<   {
<     int res= -1;
<     asm("syscall\n"
<         : "=a"(res)
<         : "0"(32), "D"(fd)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
< 
<   // __NR_dup = 33
<   inline int dup2(fd_t ofd, fd_t nfd)
<   {
<     int res= -1;
<     asm("syscall\n"
<         : "=a"(res)
<         : "a"(33), "D"(ofd), "S"(nfd)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR_nanosleep = 35
<   inline int nanosleep(timespec_p rqtp, timespec_p rmtp)
<   {
<     uint64_t res= 0xfeebdaed;
<     asm("\tsyscall;\n"
<         : "=a"(res)
<         : "0"(35), "D"(rqtp), "S"(rmtp)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
< 
<   inline int sleep(time_t secs)
<   {
<     uint64_t res= 0xfeebdaed;
<     timespec_t rqtp, rmtp;
< 
<     rqtp.tv_sec=secs;
<     rqtp.tv_nsec=0;
<     rmtp.tv_sec=0;
<     rmtp.tv_nsec=0;
<     asm("\tsyscall;\n"
<         : "=a"(res)
<         : "0"(35), "D"(&rqtp), "S"(&rmtp)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR_alarm = 37
<   inline int alarm(unsigned long delay)
<   {
<     int res= -1;
<     asm("syscall\n"
<         : "=a"(res)
<         : "0"(37), "D"(delay)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR_getpid = 39
<   inline int getpid()
<   {
<     int res= -1;
<     asm("syscall\n" : "=a"(res) : "0"(39) : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR__ fork = 57 
<   inline int fork()
<   {
<     int res= -1;
<     asm("syscall\n" : "=a"(res) : "0"(57) : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NO__ execve = 59
<   inline int execve(const char * fn, char *const * argv, char *const * envp)
<   {
<     long res;
<     asm("syscall"
<         : "=a"(res)
<         : "a"(59), "D"(fn), "S"(argv), "d"(envp)
<         : "rcx", "r11", "memory");
<     chk_return(res);
< 
<   }
< // __NR__ exit = 60 
<   // __NR_exit = 60
<   inline void exit(int res)
<   {
<     int exit_val;
<     exit_val= res & 0xff;
<     asm("syscall\n"
<         : "=a"(res)
<         : "a"(60), "D"(exit_val)
<         : "rcx", "r11", "memory");
<     while(1)
<       ;
<   }
< 
<   // __NR__ wait4 = 61 
< 
<   inline int wait4(pid_t upid, int32_p stat_p, int opt, rusage_p ru)
<   {
< 
<     uint64_t res;
< 
<     __asm__ volatile(
<              "\tsyscall;\n"
<              : "=a"(res)
<              : "0"(61), "D"(upid), "S"(stat_p), "d"(opt), "g"(ru)
<              : "rcx", "memory", "r8", "r9");
< 
<     chk_return(res);
<   }
<   inline int waitpid(pid_t pid, int32_p wstat, int opt)
<   {
<     return wait4(pid,wstat,opt,NULL);
<   }
<   inline int wait(int32_p wstat)
<   {
<     return waitpid(-1,wstat,0);
<   }
< 
<   // __NR__ kill=62
<   inline int kill(pid_t pid, int sig)
<   {
<     uint64_t res= 0xfeebdaed;
<     asm("\tsyscall;\n"
<         : "=a"(res)
<         : "0"(62), "D"(pid), "S"(sig)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
< 
<   // __NR__ uname = 63 
< 
<   inline int uname(utsname_p name)
<   {
<     time_t res= -1;
<     asm("syscall\n"
<         : "=a"(res)
<         : "a"(63), "D"(name)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
< 
<   // __NR__ rename = 82
<   inline int rename(istr_t oldname, istr_t newname)
<   {
<     uint64_t res= 0xfeebdaed;
<     asm("\tsyscall;\n"
<         : "=a"(res)
<         : "0"(82), "D"(oldname), "S"(newname)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   //#define __NR_time 201
<   inline time_t time(time_t* buf)
<   {
<     time_t res= -1;
<     asm("syscall\n"
<         : "=a"(res)
<         : "a"(201), "D"(buf)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR_getdents = 217
<   inline ssize_t getdents(fd_t fd, linux_dirent64* buf, size_t len)
<   {
<     long res;
<     asm("syscall"
<         : "=a"(res)
<         : "a"(217), "D"(fd), "S"(buf), "d"(len)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
<   // __NR__ pipe2 = 293 
< 
<   inline int pipe2(fd_p fds, int flags)
<   {
<     uint64_t res= 0xfeebdaed;
<     asm("\tsyscall;\n"
<         : "=a"(res)
<         : "0"(293), "D"(fds), "S"(flags)
<         : "rcx", "r11", "memory");
<     chk_return(res);
<   }
< } // namespace sys
< 
< namespace sys
< {
< 
<   inline ssize_t write(int fd, const char* buf, const char* end) AAI;
<   inline ssize_t write(fd_t fd, const char* buf) AAI;
< 
<   inline ssize_t write(int fd, const char* buf, const char* end)
<   {
<     return write(fd, buf, end - buf);
<   }
< 
<   inline ssize_t write(fd_t fd, const char* buf)
<   {
<     const char* end= buf ? buf : "(null)";
<     while(*end)
<       ++end;
<     return write(fd, buf, end - buf);
<   }
< 
<   inline ssize_t full_write(int fd, const char* const beg, size_t len)
<     AAI;
<   inline const char* full_write(int               fd,
<                                 const char* const beg,
<                                 const char*       end)
<     AAI;
< 
<   inline const char* full_write(int               fd,
<                                 const char* const beg,
<                                 const char*       end)
<   {
<     const char* pos= beg;
<     while(pos != end)
<     {
<       ssize_t res= write(fd, pos, end - pos);
<       if(res < 0)
<         return nullptr;
<       pos+= res;
<     }
<     return pos;
<   }
<   inline ssize_t full_write(int fd, const char* const beg, size_t len)
<   {
<     return full_write(fd, beg, beg + len) - beg;
<   }
< } // namespace sys
< 
< #define L(x) x, sizeof(x) - 1
< 
< 
< namespace std
< {
<   void        abort() __attribute__((__noreturn__));
<   inline void abort()
<   {
<     do
<     {
<       asm("int3");
<     } while(true);
<   }
<   void terminate() noexcept __attribute__((__noreturn__));
<   using ::free;
<   using ::malloc;
<   using ::memset;
<   using ::realloc;
<   using ::size_t;
<   enum nothrow_t
<   {
<   };
<   extern const nothrow_t nothrow;
<   typedef void (*new_handler)();
< }
< extern "C"
< {
<   void        abort() __attribute__((__noreturn__));
<   inline void abort()
<   {
<     do
<     {
<       asm("int3");
<     } while(true);
<   }
< }
< 
< #undef AAI
< #define _GLIBCXX_NOEXCEPT noexcept
< #ifndef _GLIBCXX_NOTHROW
< #define _GLIBCXX_NOTHROW
< #endif
< 
< extern "C" {
<   int main(int argc, char**argv, char**envp);
< };
< 
< #endif
---
> #include <linux/syscall.hh>
diff '--color=auto' -r main/inc/types.hh refactor/inc/types.hh
1,252c1
< #ifndef types_hh
< #define types_hh types_hh
< 
< typedef char* ostr_t;
< typedef const char* istr_t;
< typedef istr_t istr_v[];
< typedef signed char int8_t;
< typedef unsigned char uint8_t;
< typedef int   int32_t;
< typedef int32_t* int32_p;
< typedef long  int64_t;
< typedef unsigned uint32_t;
< typedef uint32_t* uint32_p;
< typedef unsigned long uint64_t;
< typedef uint64_t* uint64_p;
< typedef unsigned short int uint16_t;
< typedef void* void_p;
< 
< struct iocb;
< typedef long int __fd_mask;
< struct fd_set
< {
<   __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];
< };
< typedef fd_set* fd_set_p;
< struct sigaction_t {
< 	void (*sa_handler) (int);
< 	unsigned long sa_flags;
< 	void (*sa_restorer) (void);
< 	unsigned long sa_mask;
< };
< struct stat_t {
<   uint64_t  st_dev;
<   uint64_t  st_ino;
<   uint32_t  st_mode;
<   uint32_t  st_nlink;
<   uint32_t  st_uid;
<   uint32_t  st_gid;
<   uint64_t  st_rdev;
<   uint64_t  __pad1;
<   int64_t   st_size;
<   int32_t   st_blksize;
<   int32_t   __pad2;
<   int64_t   st_blocks;
<   int64_t   st_atime;
<   uint64_t  st_atime_nsec;
<   int64_t   st_mtime;
<   uint64_t  st_mtime_nsec;
<   int64_t   st_ctime;
<   uint64_t  st_ctime_nsec;
<   uint32_t  __unused4;
<   uint32_t  __unused5;
< };
< typedef sigaction_t* sigaction_p;
< typedef uint64_t sigset_t;
< typedef sigset_t *sigset_p;
< struct iovec;
< typedef iovec* iovec_p;
< struct timeval;
< typedef timeval* timeval_p;
< struct sockaddr;
< typedef sockaddr* sockaddr_p;
< struct shmid_ds;
< typedef shmid_ds* shmid_ds_p;
< struct itimerval;
< typedef itimerval* itimerval_p;
< struct msghdr;
< typedef msghdr* msghdr_p;
< struct rusage;
< typedef rusage* rusage_p;
< struct utsname;
< struct utsname
< {
<   char sysname[65];
<   char nodename[65];
<   char release[65];
<   char version[65];
<   char machine[65];
<   char domainname[65];
< };
< typedef utsname* utsname_p;
< struct sembuf;
< typedef sembuf* sembuf_p;
< struct msgbuf;
< typedef msgbuf* msgbuf_p;
< 
< struct msqid_ds;
< typedef msqid_ds* msqid_ds_p;
< typedef int qid_t;
< struct linux_dirent;
< typedef linux_dirent* linux_dirent_p;
< struct linux_dirent64;
< typedef linux_dirent64* linux_dirent64_p;
< struct sigevent;
< typedef sigevent* sigevent_p;
< struct timer_t;
< typedef timer_t* timer_p;
< struct timezone;
< typedef timezone* timezone_p;
< struct rlimit;
< typedef rlimit* rlimit_p;
< struct rlimit64;
< struct file_handle;
< typedef file_handle* file_handle_p;
< typedef rlimit64* rlimit64_p;
< struct sysinfo;
< struct cap_user_header;
< struct siginfo_t;
< typedef siginfo_t* siginfo_p;
< struct stack_t;
< typedef stack_t* stack_p;
< struct utimbuf;
< typedef utimbuf* utimbuf_p;
< struct cap_user_data;
< struct ustat;
< typedef ustat* ustat_p;
< struct statfs;
< struct bpf_attr;
< typedef bpf_attr* bpf_attr_p;
< struct sched_attr;
< typedef sched_attr* sched_attr_p;
< struct sched_param;
< typedef sched_param* sched_param_p;
< struct sysctl_args;
< typedef sysctl_args* sysctl_args_p;
< struct task_struct;
< typedef task_struct* task_struct_p;
< struct timex;
< typedef timex* timex_p;
< struct vptr_t;
< struct pt_regs;
< typedef pt_regs* pt_regs_p;
< struct aio_context_t;
< typedef aio_context_t* aio_context_p;
< struct io_event;
< typedef io_event* io_event_p;
< struct iocb;
< struct itimerspec;
< typedef itimerspec* itimerspec_p;
< struct epoll_event;
< typedef epoll_event* epoll_event_p;
< struct mq_attr;
< typedef mq_attr* mq_attr_p;
< struct stat;
< struct pollfd;
< typedef pollfd* pollfd_p;
< typedef stat* stat_p;
< typedef iocb* iocb_p;
< typedef cap_user_header* cap_user_header_t;
< typedef int mqd_t;
< typedef cap_user_data* cap_user_data_t;
< typedef sysinfo* sysinfo_p;
< typedef statfs* statfs_p;
< typedef int key_t;
< typedef key_t* key_p;
< typedef int sig_t;
< typedef sig_t* sig_p;
< typedef int uid_t;
< typedef uid_t* uid_p;
< typedef int gid_t;
< typedef gid_t* gid_p;
< typedef int umode_t;
< struct kexec_segment;
< typedef kexec_segment* kexec_segment_p;
< struct robust_list_head;
< typedef robust_list_head* robust_list_head_p;
< //   typedef int64_t quad_t;
< //   typedef char_ptr caddr_t;
< //   typedef int32_t daddr_t;
< typedef int32_t key_t;
< typedef int32_t pid_t;
< //   typedef int32_t sig_atomic_t;
< //   typedef int64_t blkcnt64_t;
< //   typedef int64_t blkcnt_t;
< //   typedef int64_t blksize_t;
< //   typedef int64_t fsword_t;
< //   typedef int64_t intmax_t;
< typedef long errno_t;
< typedef int64_t intptr_t;
< typedef uint64_t uintptr_t;
< typedef int64_t off64_t;
< typedef uint32_t fd_t;
< typedef fd_t* fd_p;
< struct pollfd_t {
<   fd_t   fd;
<   short events;
<   short revents;
< };
< typedef int64_t clock_t;
< typedef int64_t off_t;
< typedef off_t* off_p;
< struct perf_event_attr;
< typedef perf_event_attr* perf_event_attr_p;
< typedef int64_t suseconds_t;
< typedef int64_t syscall_slong_t;
< typedef int32_t clockid_t;
< typedef int64_t time_t;
< typedef time_t* time_p;
< namespace std {
< typedef int64_t ptrdiff_t;
< };
< using std::ptrdiff_t;
< typedef uint32_t mode_t;
< typedef uint64_t size_t;
< typedef uint64_t* size_p;
< typedef int64_t ssize_t;
< typedef uint64_t ino64_t;
< struct timeval
< {
<   time_t tv_sec;
<   int64_t tv_nsec;
< };
< struct timespec
< {
<   time_t tv_sec;
<   int64_t tv_nsec;
< };
< typedef timespec timespec_t;
< enum ftype_t {
< 	DT_UNKNOWN = 0,
< 	DT_FIFO = 1,
< 	DT_CHR = 2,
< 	DT_DIR = 4,
< 	DT_BLK = 6,
< 	DT_REG = 8,
< 	DT_LNK = 10,
< 	DT_SOCK = 12,
< 	DT_WHT = 14
< };
< struct linux_dirent {
< 	ino64_t        d_ino;    /* 64-bit inode number */
< 	off64_t        d_off;    /* 64-bit offset to next structure */
< 	unsigned short d_reclen; /* Size of this dirent */
< 	unsigned char  d_type;   /* File type */
< 	char           d_name[]; /* Filename (null-terminated) */
< 
< 	linux_dirent *next() {
< 		return (linux_dirent*)(((char*)this)+this->d_reclen);
< 	};
< };
< struct iovec {
< 	void  *iov_base;
< 	size_t iov_len;
< };
< 
< typedef timespec* timespec_p;
< 
< #define NULL nullptr
< //#define offsetof(type, field)	((long) &((type *)0)->field)
< #define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)
< 
< #endif
---
> #include <linux/types.hh>
Only in refactor: kernpp
Only in main/lib: abi.cc
Only in main/lib: c_str.cc
Only in main/lib: cxxabi.cc
Only in main/lib: dbg.cc
Only in main/lib: delete.cc
Only in main/lib: dyncast.cc
Only in main/lib: errno.cc
Only in main/lib: getopt.cc
Only in main/lib: init_array.cc
Only in main/lib: mm.cc
Only in main/lib: new.cc
Only in main/lib: start.S
Only in refactor/lib: start.SS
Only in main/lib: stdlib.cc
Only in main/lib: strerror_list.cc
Only in main/lib: type_info.cc
Only in main/lib: unistd.cc
Only in main/lib: write_buf.cc
Only in refactor/lib: xxx.cc
Only in refactor/lib: zzz.cc
Only in refactor: linux
Only in refactor/sbin: gen-headers.pl
Only in refactor/sbin: gen-list.pl
Only in refactor/sbin: gen-strerror.pl
Only in refactor/sbin: gen-syscall.pl
Only in refactor/sbin: gen-utimevals.c
Only in main/sbin: genheaders.pl
Only in main/sbin: genlist.pl
Only in main/sbin: genstrerror.pl
Only in main/sbin: gensyscall.pl
Only in refactor: scrap
Only in main/: script
Only in main/: test.pl
Only in refactor: tst

Only in main/: .clang-format
Only in foo: .gdbinit
diff '--color=auto' -r main/.git foo/.git
1c1
< gitdir: /home/nn/src/git/hub/.git/worktrees/main
---
> gitdir: /home/nn/src/git/hub/.git/worktrees/foo
diff '--color=auto' -r main/.gitignore foo/.gitignore
1,7c1,49
< depends.mk
< bin/markout
< **.d
< **.[os]
< **.ii
< **.a
< log/
---
> #programs
> bin/new
> bin/rc
> bin/static
> bin/cat
> bin/echo
> bin/false
> bin/ls
> bin/true
> bin/malloc_test
> bin/sc
> bin/vec
> bin/brk
> 
> *.map
> # Prerequisites
> *.d
> 
> # Compiled Object files
> *.slo
> *.lo
> *.o
> *.obj
> *.s
> *.i
> *.ii
> *.d
> 
> # Precompiled Headers
> *.gch
> *.pch
> 
> # Compiled Dynamic libraries
> *.so
> *.dylib
> *.dll
> 
> # Fortran module files
> *.mod
> *.smod
> 
> # Compiled Static libraries
> *.lai
> *.la
> *.a
> *.lib
> 
> # Executables
> *.exe
9,21c51,53
< bin/report
< bin/string_view
< output
< tags
< trace
< .gdb_history
< core.*
< out
< fuck
< ,/bin/lspath
< bin/lspath
< *.oo
< *.aa
---
> *.app
> 
> 
diff '--color=auto' -r main/Makefile foo/Makefile
1,55c1
< MAKEFLAGS:= -rR -j24
< .EXPORT_ALL_VARIABLED:
< all:
< define dir_infer
< 
< $1/src:=  $(wildcard  $1/*.cc)                         
< $1/exe:=  $(patsubst  %.cc,%,   $($1/src))             
< $1/asm:=  $(wildcard  $1/*.S)                          
< $1/xxx:=  $(patsubst  %,%.o,   $($1/asm))             
< $1/exe+=  $(patsubst  %,%,      $($1/asm))             
< $1/obj:=  $(patsubst  %,%.o,   $($1/src))             
< $1/cpp:=  $(patsubst  %,%.ii,   $($1/src))             
< $1/dep:=  $(patsubst  %,%.d,    $($1/obj)   $($1/cpp)  $($1/asm))
< $1:=$($1/exe)
< endef
< $(call dir_infir,bin,lib) 
< 
< all/obj:= $(lib/obj) $(bin/obj)
< all/xxx:= $(lib/xxx) $(bin/xxx)
< all/cpp:= $(lib/cpp) $(bin/cpp)
< all/src:= $(lib/src) $(bin/src)
< all/dep:= $(lib/dep) $(bin/dep)
< 
< include /dev/null $(wildcard $(all/dep))
< 
< ext/obj:= $(filter-out $(all/obj), $(wildcard *.o))
< ext/xxx:= $(filter-out $(all/xxx), $(wildcard *.o))
< 
< all:= $(bin/exe) $(lib/lib)
< bin:= $(bin/exe)
< lib:= $(lib/lib)
< $(bin): $(lib)
< all: $(all)
< 
< include /dev/null $(wildcard $(all/dep))
< 
< $(lib/lib): $(lib/obj) $(lib/xxx)
< 	sbin/arch "$@" $(lib/obj) $(lib/xxx)
< 
< $(bin/exe): %: %.o sbin/link etc/ld_flags
< 	sbin/link "$@" $(lib/lib)
< 
< $(all/cpp): %.ii: %.cc sbin/prec etc/cppflags
< 	rm -f $*.ii $*.o
< 	sbin/prec "$@"
< 
< $(all/xxx): %.o: %.S sbin/casm etc/asmflags
< 	sbin/casm "$@"
< 
< $(all/obj): %.o: %.ii sbin/comp etc/cxxflags
< 	sbin/comp "$@"
< 
< cur/dep:=$(wildcard *.o.d)
< cur/obj:=$(wildcard *.o) $(patsubst %.d,%,$(cur/dep))
< cur/src:=$(patsubst %.o,%.cc,$(cur/obj))
---
> test: test_ls
58,59c4,69
< ifneq ($(have),$(want))
< $(lib/lib): rem-lib
---
> test_ls: bin/ls | all
> 	@echo testing $<
> 	bin/ls */*.[ch][ch]
> 
> test_%: bin/% | all
> 	@echo testing $<
> 	./bin/$*
> 
> test_algo: algo
> 	./algo * */*.[ch][ch] *.cc *.cc *.cc
> 
> algo: algo.cc
> 	$(CXX) algo.cc -o algo
> 
> 
> MAKEFLAGS:=-rR
> ARFLAGS = rvU
> 
> CXX:= g++
> LD= ld -Map $@.map
> 
> CPP_FLAGS= -MD -MF $@.d -MT $@
> CPP_FLAGS+= -Iinclude
> CPP_FLAGS+= -nostdinc
> 
> CXX_FLAGS:= @cxx_flags
> 
> #bin/ls.s: CXX_FLAGS+=-fexceptions
> 
> DEPS=/dev/null
> 
> include/syscall_fwd.hh: script/genheaders.pl script/syscall.pl
> 	perl script/genheaders.pl > $@
> 
> BIN_CXX:=$(wildcard bin/*.cc)
> BIN_GEN:=$(patsubst %.cc, %.s, $(BIN_CXX))
> BIN_ASM:=$(filter-out $(BIN_GEN), $(wildcard bin/*.s))
> BIN_GEN+=$(patsubst %.s, %.o, $(BIN_GEN) $(BIN_ASM))
> DEPS+=$(patsubst %.cc,%.d,$(BIN_CXX))
> 
> LIB_CXX:=$(filter-out lib/save_this.cc, $(wildcard lib/*.cc))
> LIB_GEN:=$(patsubst %.cc, %.s, $(LIB_CXX))
> LIB_ASM:=$(filter-out  lib/save_this.s $(LIB_GEN), $(wildcard lib/*.s))
> LIB_OBJ:=$(patsubst %.s, %.o, $(LIB_GEN) $(LIB_ASM))
> LIB_GEN+=$(LIB_OBJ)
> DEPS+=$(patsubst %.cc,%.d,$(LIB_CXX))
> 
> ASM_EXE:=$(patsubst %.s, %, $(BIN_ASM))
> CXX_EXE:=$(patsubst %.cc, %, $(BIN_CXX))
> BIN_EXE:=$(ASM_EXE) $(CXX_EXE)
> 
> .PRECIOUS: $(BIN_GEN) $(LIB_GEN)
> 
> (%): %
> 	ar $(ARFLAGS) $@ $<
> 
> lib/libkernpp.a: $(patsubst %, lib/libkernpp.a(%), $(LIB_OBJ)) $(START)
> 
> $(ASM_EXE): %: %.o
> 	$(LD) -o $@ $<
> 
> $(CXX_EXE): %: %.o lib/start.o lib/libkernpp.a
> ifdef LINK_WITH_CXX
> 	$(CXX) -static -nostartfiles $(START) -o $@ $< lib/libkernpp.a
> else
> 	$(LD) $(START) -o $@ $< lib/libkernpp.a
62,63c72,75
< ###   
< clean: date:=$(shell serdate)
---
> ifdef SKIP_PREPROC
> %.s: %.cc cxx_flags
> 	$(CXX) $(CXX_FLAGS) $(CPP_FLAGS) -S $< -o $@ 
> else
65,66c77,81
< clean:
< 	rm -f */*.[ioad]
---
> %.ii: %.cc cxx_flags
> 	$(CXX) $(CXX_FLAGS) $(CPP_FLAGS) -E $< -o $@ 
> 
> %.s: %.ii cxx_flags
> 	$(CXX) $(CXX_FLAGS) $(CPP_FLAGS) -S $< -o $@ 
68,71c83,91
< $(all/obj): sbin/comp
< $(bin/exe): sbin/link
< $(lib/lib): sbin/arch
< $(bin/exe): $(lib)
---
> endif
> 
> #    bin/static.o: %.o: %.s
> #    	$(CXX) -g -c $< -o $@
> 
> %.o: %.s
> 	$(CXX) -c $< -o $@
> 
> all: $(BIN_EXE)
73,74c93,130
< tags: */*.cc */*.hh
< 	ctags --language-force=c++ */*.cc */*.hh
---
> bin/%.out: bin/%.sh bin/%
> 	bash $< > $@
> 
> test: all
> 
> clean:
> 	rm -f deps $(BIN_GEN) $(ASM_EXE) $(CXX_EXE) $(LIB_GEN) lib/libkernpp.a
> 	rm -f $(patsubst %.cc,%.d,$(BIN_CXX) $(LIB_CXX))
> 	touch deps
> 
> show:
> 	@echo ASM_EXE=$(ASM_EXE)
> 	@echo CXX_EXE=$(CXX_EXE)
> 	@echo
> 	@echo BIN_ASM=$(BIN_ASM)
> 	@echo BIN_CXX=$(BIN_CXX)
> 	@echo BIN_EXE=$(BIN_EXE)
> 	@echo BIN_GEN=$(BIN_GEN)
> 	@echo
> 	@echo LIB_ASM=$(LIB_ASM)
> 	@echo LIB_CXX=$(LIB_CXX)
> 	@echo LIB_GEN=$(LIB_GEN)
> 	@echo LIB_OBJ=$(LIB_OBJ)
> 
> Makefile: ;
> 
> deps: $(wildcard $(DEPS))
> 	@cat $(sort $(wildcard $(DEPS))) > deps.new
> 	@cmp deps deps.new && rm -f deps.new && touch deps || mv -v deps.new deps
> 
> include deps
> 
> check_env:
> 	printenv
> 
> SOURCES:= $(wildcard */*.cc */*.hh */*.s )
> tags: .PHONY
> 	ctags $(SOURCES)
76,77c132
< nm:
< 	nm */*.a */*.o --defined-only -A --demangle
---
> .PHONY: test clean show all
diff '--color=auto' -r main/README.md foo/README.md
2,10c2
< A c++ library that runs right on top of the Linux kernel.
< 
< First, let's be clear, I'm doing this on a lark.  I don't know if it
< will be useful to me or to anyone long term.  I am experimenting on some
< ideas for c++ code without the huge libc baggage.  I would like to try
< some different things, and I figure I might as well do it publicly.
< I appreciate suggestions, but this is my project to fuck around.
< I might not do it the right way because I am interested in discovering
< the characteristics of the wrongness produced by doing it the wrong way.
---
> A c++ library that runs right on top of the Linux kernel
Only in main/bin: .gitignore
Only in foo/bin: brk.cc
diff '--color=auto' -r main/bin/cat.cc foo/bin/cat.cc
1d0
< #include <fmt.hh>
3d1
< #include <getopt.hh>
5,33c3,11
< using namespace fmt;
< void fatal(const char* message, size_t len)
< {
<   if(len < 0)
<     len= strlen(message);
<   write(2, message, len);
<   exit(1);
< }
< void fatal(const char* message)
< {
<   fatal(message, strlen(message));
< }
< template <size_t size_>
< struct sbuf_t
< {
<   enum
<   {
<     size= size_
<   };
<   char  buf[size - 1];
<   char  end[1];
<   char* b()
<   {
<     return buf;
<   };
<   char* e()
<   {
<     return end;
<   };
---
> ssize_t full_write(int fd, const char * const beg, const char *end){
> 	const char*pos=beg;
> 	while(pos!=end){
> 		ssize_t res=write(fd,pos,end-pos);
> 		if(res<0)
> 			return -1;
> 		pos+=res;
> 	};
> 	return pos-beg;
35,49c13,26
< static sbuf_t<1024 * 10> buf;
< using namespace sys;
< bool catfile(int ifd, int ofd)
< {
<   while(true)
<   {
<     size_t rres= read(ifd, buf.buf, sizeof(buf.buf));
<     if(rres == 0)
<       return true;
<     if(rres < 0)
<       fatal(L("read error\n"));
<     size_t wres= full_write(ofd, buf.buf, rres);
<     if(wres != rres)
<       fatal(L("write error\n"));
<   };
---
> static char buf[1L<<16];
> bool catfile(int fd) {
> 	ssize_t res=0;
> 	while((res=read(fd,buf,sizeof(buf)))>0)
> 	{
> 		ssize_t wres=full_write(1,buf,buf+res);
> 		if(wres!=res){
> 			write(2,L("write error\n"));
> 			return false;
> 		};
> 	}
> 	if(res<0)
> 		write(2,L("read error\n"));
> 	return !res;
51,74c28,45
< 
< const char *program_name=nullptr;
< struct opts_t
< {
<   int num;
<   int empty;
<   int show_non;
<   int show_tab;
<   int show_end;
<   opts_t()
<     : num(0), empty(0), show_non(0), show_tab(0), show_end(0)
<   {
<   };
< 
< } opts;
< 
< static struct option long_options[] = {
<   { "number", no_argument, 0, 'n' },
<   { "number-non-empty", no_argument, 0, 'b' },
<   { "show-nonprinting", no_argument, 0, 'v' },
<   { "show-tabs", no_argument, 0, 't' },
<   { "show-ends", no_argument, 0, 'e' },
<   { "show-all", no_argument, 0, 'A' },
<   { 0, 0, 0, 0 },
---
> int main(int argc, char**argv) {
> 	++argv;
> 	if(*argv) {
> 		while(*argv)
> 		{
> 			int fd=open(*argv,0);
> 			if(fd<0){
> 				write(2,L("open error\n"));
> 				return 1;
> 			};
> 			catfile(fd);
> 			close(fd);
> 			++argv;
> 		}	
> 	} else {
> 		catfile(0);
> 	};
> 	return 0;
76,166d46
< int main(int argc, char** argv,char**envp)
< {
<   int c;
<   c_str names[argc];
<   int nnames=0;
<   while(1)
<   {
<     int this_option_intind = optind ? optind: 1;
<     int option_index=0;
<     c=getopt_long(argc,argv,"nbvteA",long_options,&option_index);
<     switch(c) {
<       case -1:
<         names[nnames++]=argv[optind++];
<         break;
<       case 0:
<         write(1,L("option: "));
<         write(1,long_options[option_index].name);
<         write(1,L("\n"));
<         break;
<       case 'n':
<         opts.num=1;
<         opts.empty=1;
<         break;
<       case 'b':
<         opts.num=1;
<         opts.empty=0;
<         break;
<       case 'v':
<         opts.show_non=1;
<         break;
<       case 't':
<         opts.show_tab=1;
<         break;
<       case 'e':
<         opts.show_end=1;
<         break;
<       case 'A':
<         opts.show_non=1;
<         opts.show_tab=1;
<         opts.show_end=1;
<         break;
<       default: 
<         write(2,L("unexpected option'"));
<         char chs[2];
<         chs[0]=c;
<         chs[1]=0;
<         write(2,c_str(chs,chs+1));
<         write(2,"'\n");
<         sys::exit(1);
<     };
<     if(optind==argc)
<       break;
<   };
<   for(int i=0;i<nnames;i++)
<   {
<     auto &name=names[i];
<     if(name=="--")
<       continue;
<     else if (name=="-")
<       catfile(0,1);
<     else {
<       int fd=open(name.begin(),o_rdonly);
<       if(fd<0) {
<         write(2,"open:");
<         write(2,name.begin());
<         write(2,":",1);
<         write_dec(2,errno);
<         write(2,":",1);
<         write(2,strerror(errno));
<         write(2,"\n",1);
<       } else {
<         catfile(fd,1);
<       };
<     };
<   };
<   return 0;
< }
< #if 0
< BusyBox v1.27.2 (Ubuntu 1:1.27.2-2ubuntu3.2) multi-call binary.
< 
< Usage: cat [-nbvteA] [FILE]...
< 
< Print FILEs to stdout
< 
< 	-n	Number output lines
< 	-b	Number nonempty lines
< 	-v	Show nonprinting characters as ^x or M-x
< 	-t	...and tabs as ^I
< 	-e	...and end lines with $
< 	-A	Same as -vte
< #endif
diff '--color=auto' -r main/bin/echo.cc foo/bin/echo.cc
2d1
< using sys::write;
4,13c3,16
< int main(int argc, char**argv,char **envp) {
<   ++argv;
<   if(*argv)
<     write(1, *argv++);
<   while(*argv) {
<     write(1,L(" "));
<     write(1, *argv++);
<   };
<   write(1, L("\n"));
<   return 0;
---
> void err_exit(const char *message){
> 	ssize_t res=write(2,message);
> 	exit(1);
> };
> int main(int argc, char*argv[]) {
> 	++argv;
> 	if(*argv)
> 		write(1, *argv++);
> 	while(*argv) {
> 		write(1,L(" "));
> 		write(1, *argv++);
> 	};
> 	write(1, L("\n"));
> 	return 0;
Only in main/bin: false.S
Only in foo/bin: false.s
diff '--color=auto' -r main/bin/ls.cc foo/bin/ls.cc
4d3
< #include <getopt.hh>
6,116c5,25
< using sys::write;
< using sys::errno;
< 
< template<typename obj_t>
< void swap(obj_t &lhs, obj_t &rhs)
< {
<   obj_t tmp(lhs);
<   lhs=rhs;
<   rhs=tmp;
< };
< enum ignore_t {
<   normal,
<   minimal,
<   dot_dot,
< } ignore;
< extern "C" {
<   void mm_show();
< };
< bool dotfiles=false;
< static void *ptrs[4096];
< static size_t nptr=0;
< using namespace sys;
< 
< int sign(int lhs){
<   if(lhs<0)
<     return -1;
<   else if (lhs>0)
<     return 1;
<   else
<     return 0;
< };
< int cmp(const char *lhs, const char *rhs){
<   while(*lhs == *rhs && *lhs)
<     ++lhs, ++rhs;
<   return sign(*lhs-*rhs);
< };
< void sort(linux_dirent **beg, linux_dirent**end)
< {
<   if(beg==end)
<     return;
<   linux_dirent** pos=beg;
<   while(pos<end){
<     while(++beg<end){
<       if(cmp((*beg)->d_name,(*pos)->d_name)<0)
<         swap(*beg,*pos);
<     }
<     pos++;
<     beg=pos;
<   }
< };
< bool skip(const char *name){
<   if(name[0]!='.')
<     return false;
<   if(ignore==normal)
<     return true;
<   if(ignore==minimal)
<     return false;
<   if(name[1]==0)
<     return true;
<   if(name[1]=='.' && name[2]==0)
<     return true;
<   return false;
< };
< void lsdir(int fd) {
<   int n=0;
<   linux_dirent*ents[8192];
<   enum { size = 4096 };
<   char buf[size];
<   for(;;){
<     int nread=getdents(fd,(linux_dirent*)(char*)buf,size);
<     if(nread<0)
<       pexit("getdents");
<     else if (nread==0)
<       break;
<     auto beg = reinterpret_cast<linux_dirent*>(&buf[0]);
<     auto end = reinterpret_cast<linux_dirent*>(&buf[nread]);
<     while(beg!=end){
<       if(!skip(beg->d_name)){
<         ents[n++]=beg;
<       };
<       beg=beg->next();
<     }
<   };
<   sort(ents,ents+n);
<   for(int i=0;i<n;i++){
<     write(1,ents[i]->d_name);
<     write(1,"\n");
<   };
< };
< void lsarg(const char *path)
< {
<   int fd = open(path,open_flags(o_directory|o_rdonly));
<   if(fd>=0)
<   {
<     lsdir(fd);
<   } else if ( errno == ENOTDIR ) {
<     write(1,path);
<     write(1,"\n",1);
<   } else {
<     write(2,"open: ");
<     write(2,path);
<     write(2," failed (");
<     char buf[32];
<     char *end=&buf[sizeof(buf)-1];
<     bool neg = (errno<0);
<     unsigned long num=(neg?-1:1)*errno; 
<     char *str=fmt::fmt_dec(neg,num,buf,end);
<     write(2,str,end);
<     write(2,")\n");
<   };
<   close(fd);
---
> enum open_mode {
> 	o_rdonly  =  0000,
> 	o_wronly  =  0001,
> 	o_rdwr    =  0002,
> 	o_mask    =  0003,
> };
> enum open_flags {
> 	o_creat      =  00000100,
> 	o_excl       =  00000200,
> 	o_noctty     =  00000400,
> 	o_trunc      =  00001000,
> 	o_append     =  00002000,
> 	o_nonblock   =  00004000,
> 	o_dsync      =  00010000,
> 	o_fasync     =  00020000,
> 	o_direct     =  00040000,
> 	o_largefile  =  00100000,
> 	o_directory  =  00200000,
> 	o_nofollow   =  00400000,
> 	o_noatime    =  01000000,
> 	o_cloexec    =  02000000,
119,142c28
< static option longopts[]={
<   { "version", 0, 0, 1 },
<   { "help",    0, 0, 2 },
<   { 0, 0, 0, 0}
< };
< const char help_msg[]=
< "Usage: /bin/ls [OPTION]... [FILE]...\n"
< "List information about the FILEs (the current directory by default).\n"
< "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
< "\n"
< "Mandatory arguments to long options are mandatory for short options too.\n"
< "  -a, --all                  do not ignore entries starting with .\n"
< "  -A, --almost-all           do not list implied . and ..\n"
< "  -b, --escape               print C-style escapes for nongraphic characters\n"
< "  -d, --directory            list directories themselves, not their contents\n"
< "      --help     display this help and exit\n"
< "      --version  output version information and exit\n"
< "\n"
< "Exit status:\n"
< " 0  if OK,\n"
< " 1  if minor problems (e.g., cannot access subdirectory),\n"
< " 2  if serious trouble (e.g., cannot access command-line argument).\n"
< ;
< int help(int res)
---
> void handle_error(errno_t err, const char *call)
144,145c30,41
<   write((res?2:1),L(help_msg));
<   return 0;
---
> 	char buf[1024];
> 	char *pos=buf;
> 	char *end=buf+sizeof(buf);
> 	while(*call)
> 		*pos++=*call++;
> 	*pos++=':';
> 	call = " error\n";
> 	while(*call)
> 		*pos++=*call++;
> 	write(2,buf,pos-buf);
> 	exit(1);
> 
147,149c43,80
< int version() {
<   write(1,L("ls (kernpp) 1.0\n"));
<   return 0;
---
> char buffer[4096];
> bool lsarg(const char *dirname){
> 	int fd = open(dirname,o_directory|o_rdonly);
> 	if(fd<0)
> 		return false;
> 	for(;;){
> 		int nread=getdents(fd,(linux_dirent*)buffer,sizeof(buffer)-4);
> 		if(nread<0)
> 			handle_error(errno_t(-nread), "getdents");
> 		else if (nread==0)
> 			return 0;
> 		auto beg = reinterpret_cast<linux_dirent*>(&buffer[0]);
> 		auto end = reinterpret_cast<linux_dirent*>(&buffer[nread]);
> 		while(beg!=end){
> 			if(*beg->d_name != '.') {
> 				write(1,beg->d_name,strlen(beg->d_name));
> 				write(1,"\n",1);
> 			};
> 			beg=beg->next();
> 		};
> 	};
> };
> using namespace fmt;
> template <typename val_t>
> ssize_t write_dec(val_t val, int width=0){
> 	bool neg=val<0;
> 	if(neg)
> 		val*=-1;
> 	char buf[sizeof(val)*4];
> 	char *end=buf+sizeof(buf);
> 	*--end=0;
> 	char *pos=end;
> 	pos=fmt_dec(val,buf,end);
> 	if(neg)
> 		*--pos='-';
> 	while(end-pos<width)
> 		*--pos=' ';
> 	return write(1,pos,end);
151c82,85
< int main(int argc, char**argv,char**envp) 
---
> 
> using namespace fmt;
> 
> int main(int argc, char**argv) 
153,188c87,103
<   int ch;
<   int longidx=0;
<   signed long u=1;
<   signed long lu=0;
<   // show directory contents
<   bool dir_cont=true;
<   if(dup2(1,2)<0)
<     pexit("dup2");
<   using fmt::write_dec;
<   while((ch=getopt_long(argc,argv,"aA",longopts,&longidx))!=-1)
<   {
<     switch(ch) {
<       case 1: return version();
<       case 2: return help(0);
<       case 'a': ignore=minimal; break;
<       case 'A': ignore=dot_dot; break;
<       case 'd': dir_cont=false; break;
<       default: return help(1);
<     };
<   };
<   if(optind<argc) {
<     for(int i=optind;i<argc;i++){
<       lsarg(argv[i]);
<     };
<   } else {
<     lsarg(".");
<   };
<   for(int i=0;i<nptr;i++) {
<     if(ptrs[i]){
<       fmt::write_ptr(2,ptrs[i]);
<       write(2,L("\n"));
<       free(ptrs[i]);
<       ptrs[i]=0;
<     };
<   };
<   return 0;
---
> 	write(1,L("main called with argc="));
> 	write_dec(argc);
> 	write(1,L("\n"));
> 
> 	int *argl = new int[argc];
> 	for(int i=0;i<argc;i++) {
> 		argl[i]=strlen(argv[i]);
> 	};
> 	for(int i=0;i<argc;i++){
> 		write_dec(argl[i],10);
> 		write(1,L(" "));
> 		write(1,argv[i],argl[i]);	
> 		write(1,L("\n"));
> 	};	
> 
> //	throw "test\n";
> 	return 0;
Only in main/bin: lspath.cc
Only in foo/bin: malloc_test.cc
Only in foo/bin: new.cc
Only in main/bin: not.cc
Only in foo/bin: rc.cc
Only in main/bin: report.cc
Only in foo/bin: sc.cc
Only in foo/bin: static.cc
Only in main/bin: string_view.cc
Only in main/bin: test_getopt.cc
Only in main/bin: true.S
Only in foo/bin: true.s
Only in main/bin: usleep.cc
Only in foo/bin: vec.cc
Only in main/: breakpoints
Only in foo: cxx_flags
Only in main/: depends.pl
Only in foo: deps
Only in main/doc: all_syscalls.h
Only in main/doc: lspath.bash
Only in main/: etc
Only in main/: files.md5
Only in main/: inc
Only in foo: include
diff '--color=auto' -r main/lib/abi.cc foo/lib/abi.cc
4c4,7
<   using sys::write;
---
> 	void __cxa_pure_virtual() { 
> 		write(2,L("pure virtual function called\n"));
> 		abort();
> 	}
6,17c9,19
<   void __cxa_pure_virtual() { 
<     write(2,L("pure virtual function called\n"));
<     abort();
<   }
< 
<   void __cxa_guard_release(void*)
<   {
<   };
<   void __cxa_guard_acquire(void*)
<   {
<   };
<   void * __dso_handle=(void*)&__dso_handle;
---
> 	void __cxa_guard_release(void*)
> 	{
> 		write(1,L(__PRETTY_FUNCTION__));
> 		write(1,L("\n"));
> 	};
> 	void __cxa_guard_acquire(void*)
> 	{
> 		write(1,L("hi!\n"));
> 		write(1,L("\n"));
> 	};
> 	void * __dso_handle=(void*)&__dso_handle;
18a21,29
> 	int __cxa_atexit(
> 			void (*func) (void *), 
> 			void * arg, 
> 			void * dso_handle
> 			)
> 	{
> 		write(2,L(__PRETTY_FUNCTION__));
> 		write(2,L("\n"));
> 	}
Only in main/lib: c_str.cc
Only in main/lib: cxxabi.cc
Only in main/lib: dbg.cc
Only in main/lib: delete.cc
Only in main/lib: dyncast.cc
Only in main/lib: errno.cc
Only in main/lib: getopt.cc
diff '--color=auto' -r main/lib/init_array.cc foo/lib/init_array.cc
1,2d0
< #include <types.hh>
< #include <syscall.hh>
3a2
> typedef int fd_t;
4a4
> typedef void(* atexit_func_t)(void);
14,27d13
< #ifndef L
< #define L(x) x,sizeof(x)-1
< #endif
< inline ssize_t write( fd_t fd,  const char *buf,  size_t len)
< {
< 	long res;
< 	asm (
< 			"syscall\n"
< 			: "=a"(res)
< 			: "a"(1), "D"(fd), "S"(buf),"d"(len)
< 			: "rcx", "r11", "memory"
< 			);
< 	return res;
< };
31c17,30
< 	void exit(int return_code) __attribute__((noreturn));
---
> 	void _exit(int return_code) __attribute__((noreturn));
> 	inline void _exit(int res)
> 	{
> 		int exit_val;
> 		exit_val=res&0xff;
> 		asm (
> 				"syscall\n" 
> 				: "=a"(res) 
> 				: "a"(60), "D"(exit_val)
> 				: "rcx", "r11", "memory"
> 				);
> 		while(1);
> 	}
> 
48c47
< 		ssize_t count, i;
---
> 		size_t count, i;
50c49
< 		count = __fini_array_end - __fini_array_start;
---
> 		count = __preinit_array_end - __preinit_array_start;
52,54c51
<     {
<       __fini_array_start[i]();
<     };
---
> 			__fini_array_start[i]();
56c53
< 		//_fini();
---
> 		_fini();
61,127c58,60
< 	typedef void(*atexit_func_t)(void);
< 	typedef void(*cxa_atexit_func_t)(void *);
< 	struct exit_func {
< 		enum {
< 			ef_none=0,
< 			ef_c,
< 			ef_cxa
< 		} flavor;
< 		union {
< 			struct {
< 				cxa_atexit_func_t func;
< 				void *arg;
< 			} cxa;
< 		 	struct {
< 				void *dummy;
< 				atexit_func_t func;
< 			} c;
< 		};
< 		void call() {
< 			switch(flavor) {
< 				case ef_c:
< 					c.func();
< 					break;
< 				case ef_cxa:
< 					cxa.func(cxa.arg);
< 					break;
< 				case ef_none:
< 					write(2,L("Tried to call 'ef_none' exit func\n"));
< 					break;
< 				default:
< 					write(2,L("Tried to call invalid exit func\n"));
< 					break;
< 			};
< 		};
< 		exit_func( atexit_func_t func )
< 			: flavor(ef_c)
< 		{
< 			c.func=func;
< 		};
< 		exit_func( cxa_atexit_func_t func, void *arg )
< 			: flavor(ef_cxa)
< 		{
< 			cxa.func=func;
< 			cxa.arg=arg;
< 		};
< 		exit_func()
< 			: flavor(ef_none)
< 		{
< 		};
< 	};
< 	char func_buf[MAX_ATEXIT*sizeof(exit_func)];
< 	exit_func *funcs=(exit_func*)(0+func_buf);
< 	static size_t nfunc=0;
< 
< 	int __cxa_atexit(
< 			cxa_atexit_func_t func,
< 			void * arg, 
< 			void * dso_handle
< 			)
< 	{
< 		if(nfunc>=MAX_ATEXIT){
< 			write(2,L("Too many atexit funcs\n"));
< 			exit(1);
< 		};
< 		funcs[nfunc++]=exit_func(func,arg);
< 		return 0;
< 	}
---
> 	static volatile uint8_t atexit_count = 0;
> 	static volatile atexit_func_t atexit_funcs[MAX_ATEXIT];
> 
128a62
> 		uint8_t pos = __sync_fetch_and_add(&atexit_count, 1);
130c64,69
< 		funcs[nfunc++] = func;
---
> 		if (pos >= MAX_ATEXIT) {
> 			atexit_count = 32;
> 			return -1;
> 		}
> 
> 		atexit_funcs[pos] = func;
135,137c74,78
< 		int i=nfunc;
< 		while(i)
< 			funcs[--i].call();	
---
> 		uint8_t i;
> 
> 		for (i = 0; i < atexit_count; i++) {
> 			atexit_funcs[i]();
> 		}
140c81
<     sys::exit(return_code);
---
> 		_exit(return_code);
diff '--color=auto' -r main/lib/mm.cc foo/lib/mm.cc
2,3d1
< #include <fmt.hh>
< #include <write_buf.hh>
5,191c3,12
< using fmt::write_dec;
< using fmt::write_ptr;
< using fmt::write_hex;
< 
< namespace fmt {
<   inline char *fmt_sphex(unsigned long val, char *beg, char *end)
<   {
<     int i;
<     for(i=0;i<2*sizeof(val);i++){
<       *--end=hex_dig(val);
<       if((val/=0x10)==0)
<         break;
<     };
<     for(;i<2*sizeof(val);i++)
<       *--end=' ';
<     return end;
<   };
<   inline int write_sphex(fd_t fd, size_t hex) {
<     char buf[sizeof(hex)*4];
<     return write(fd, fmt::fmt_sphex(hex,buf,&buf[sizeof(buf)-1]));
<   };
< };
< using fmt::write_sphex;
< using fmt::fmt_sphex;
< using namespace sys;
< class block_l {
<   enum magic_t { magic = 0xdeadbeef };
<   struct block_t {
<     magic_t magic1;
<     block_t *next;
<     magic_t magic2;
<     size_t size;
<     magic_t magic3;
<     bool used;
<     void combine() {
<       if(!next)
<         return;
<       if(next->used)
<         return;
<       size+=sizeof(*next)+next->size;
<       next=next->next;
<     };
<   };
<   block_t *list;
<   public:
<   block_l()
<     :list(0)
<   {
<   };
<   void *malloc(size_t size)
<   {
<     void *res=_malloc(size);
<     if(0){
<       write_buf<> msg(2);
<       msg.put("malloc(");
<       msg.fmt(size);
<       msg.put(") => ");
<       msg.fmtln(res);
<     };
<     return res;
< 
<   };
<   void *_malloc(size_t size)
<   {
<     block_t **pos=&list;
<     while(*pos) {
<       block_t *blk=*pos;
<       void *ptr = (void*)(blk+1);
<       if( blk->magic1 != magic || blk->magic2 != magic || blk->magic3 != magic ) 
<       {
<         using fmt::hex_t;
<         write_buf<> msg(2);
<         msg.put(__FILE__);
<         msg.put(":");
<         msg.fmt(__LINE__);
<         msg.put(":");
<         msg.put("free: ");
<         msg.fmtln(ptr);
<         msg.put("blk: ");
<         msg.fmtln(blk);
<         msg.put("magic1: ");
<         msg.fmtln(hex_t((unsigned long)blk->magic1));
<         msg.put("magic2: ");
<         msg.fmtln(hex_t((unsigned long)blk->magic2));
<         msg.put("magic3: ");
<         msg.fmtln(hex_t((unsigned long)blk->magic3));
<       };
<       if(!(*pos)->used && (*pos)->size>=size) {
<         (*pos)->used=true;
<         return *pos+1;
<       };
<       pos=&((*pos)->next);
<     };
<     block_t *blk=(block_t*)sbrk(size+sizeof(block_t));
<     blk->magic1=blk->magic2=blk->magic3=magic;
<     blk->used=true;
<     blk->size=size;
<     blk->next=0;
<     *pos=blk;
<     return blk+1;
<   };
<   ~block_l() {
<     //show();
<     list=0;
<   };
<   typedef char* char_p;
<   void free(void *ptr){
<     if(!ptr)
<       return;
<     block_t *blk=(block_t*)ptr;
<     --blk;
<     if( blk->magic1 != magic || blk->magic2 != magic || blk->magic3 != magic ) 
<     {
<         using fmt::hex_t;
<       write_buf<> msg(2);
<       msg.put(__FILE__);
<       msg.put(":");
<       msg.fmt(__LINE__);
<       msg.put(":");
<       msg.put("free: ");
<       msg.fmtln(ptr);
<       msg.put("blk: ");
<       msg.fmtln(blk);
<       msg.put("magic1: ");
<       msg.fmtln(hex_t((unsigned long)blk->magic1));
<       msg.put("magic2: ");
<       msg.fmtln(hex_t((unsigned long)blk->magic2));
<       msg.put("magic3: ");
<       msg.fmtln(hex_t((unsigned long)blk->magic3));
<       msg.flush();
<     };
<     if(!blk->used) {
<       write(2,L("warning: double free of: "));
<       write_ptr(2,ptr);
<       write(2,L("\n"));
<     };
<     blk->used=false;
<     for(blk=list;blk;blk=blk->next)
<       blk->combine();
<   };
<   void show() {
<     write(2,L("(---BLOCK LIST----\n"));
<     for( block_t *blk=list; blk; blk=blk->next ) {
<       write(2,L("blk: "));
<       write_ptr(2,blk);
<       write(2,L(" data: "));
<       write_ptr(2,blk+1);
<       write(2,L(" size: "));
<       write_sphex(2,blk->size);
<       write(2,L(" used: "));
<       write_dec(2,blk->used);
<       write(2,L("\n"));
<       write(2,L("       "));
<       write_ptr(2,char_p(blk)+blk->size+sizeof(*blk));
<       write(2,L("\n"));
<     };
<     write(2,L("----BLOCK LIST---}\n"));
<   };
< };
< block_l list;
< extern "C" {
< //     void mm_show() {
< //       list.show();
< //     };
< };
< void *malloc(size_t size) {
< #if 1
<   return list.malloc(size);
< #else
<   write(2,L("malloc("));
<   write_dec(2,size);
<   write(2,L(") => "));
<   void *res=list.malloc(size);
<   write_ptr(2,res);
<   write(2,L("\n"));
<   return res;
< #endif
< };
< void *realloc(void *ptr, size_t size) {
<   char *optr=(char*)ptr;
<   char *nptr=(char*)malloc(size);
<   memcpy(nptr,optr,size);
<   free(optr);
<   return nptr;
< };
< void free(void *ptr) {
<   list.free(ptr);
---
> void *malloc(size_t size)
> {
> 	void *block;
> 	block = sbrk(size);
> 	if (block == (void*) -1)
> 		return nullptr;
> 	return block;
> }
> void free(void *vp) {
> 	write(1,L("free\n"));
197c18
<   char *newbrk;
---
> 	char *newbrk;
199,204c20,25
<   asm (
<       "syscall\n" 
<       : "=a"(newbrk) 
<       : "0"(12), "D"(addr)
<       : "rcx", "r11", "memory"
<       );
---
> 	asm (
> 			"syscall\n" 
> 			: "=a"(newbrk) 
> 			: "0"(12), "D"(addr)
> 			: "rcx", "r11", "memory"
> 			);
206c27
<   __curbrk=newbrk;
---
> 	__curbrk=newbrk;
225,226c46,47
<   if (!__curbrk && (brk(0)<0))
<     return (void*)-1;
---
> 	if (!__curbrk && (brk(0)<0))
> 		return (void*)-1;
Only in main/lib: new.cc
Only in foo/lib: rc.cc
Only in foo/lib: save_this.cc
Only in main/lib: start.S
Only in foo/lib: start.s
Only in main/lib: stdlib.cc
Only in foo/lib: stream.cc
Only in main/lib: strerror_list.cc
Only in main/lib: type_info.cc
diff '--color=auto' -r main/lib/unistd.cc foo/lib/unistd.cc
2a3,8
> namespace {
> 	int init_errno(){
> 		write(1,L("init_errno()\n"));
> 		return 0;
> 	};
> };
4c10
< 	long errno=0;
---
> 	int errno=init_errno();
Only in main/lib: write_buf.cc
Only in main/: sbin
diff '--color=auto' -r main/script/genheaders.pl foo/script/genheaders.pl
5d4
< use autodie qw(:all);
7a7
> our(%calls);
10,12d9
< 
< 
< our(%calls);
21,22d17
< print q(#file __FILE__);
< print q(#line __LINE__);
34d28
<         print "// __NR__", $call{name}, "=", $call{code}, "\n";
Only in main/script: genlist.pl
Only in main/script: genstrerror.pl
diff '--color=auto' -r main/script/gensyscall.pl foo/script/gensyscall.pl
5d4
< use autodie qw(:all);
13,20d11
< BEGIN {
<   open(STDERR,"|less -FS");
<   open(STDOUT,">&STDERR");
< };
< END {
<   close(STDOUT);
<   close(STDERR) or warn "less returned non zero\n";
< };
27a19
> our(@args);
36,37d27
< my %args;
< #print Dumper \%calls;
39,48c29,35
<   local *call=$calls{$_};
<   next unless $call{impl};
<   for(@{$call{args}}){
<     next unless ($_->[0] eq "istr_t") || ($_->[0] eq "ostr_t");
<     if( $_->[1] eq "oldname" ) {
<       $_->[1] = "opath";
<     } elsif ( $_->[1] eq "newname" ) {
<       $_->[1] = "npath";
<     };
<   };
---
> 	local *call=$calls{$_};
> 	next unless $call{impl};
> 	for(@{$call{args}}){
> 		if( $_->[0] eq "struct stat *"){
> 			$_->[0] = "stat_p";
> 		};
> 	};
50d36
< #print Dumper \%calls;
diff '--color=auto' -r main/script/syscall.pl foo/script/syscall.pl
49c49
<         'path'
---
>         'filename'
81c81
<         'path'
---
>         'filename'
113c113
<         'path'
---
>         'filename'
257a258,261
>       ],
>       [
>         'size_t',
>         'sigsetsize'
413c417
<         'path'
---
>         'filename'
1083c1087
<   'sys_clone' => {
---
>   'clone' => {
1504c1508
<         'path'
---
>         'filename'
1528c1532
<         'opath'
---
>         'oldname'
1532c1536
<         'npath'
---
>         'newname'
1544c1548
<         'path'
---
>         'pathname'
1560c1564
<         'path'
---
>         'pathname'
1572c1576
<         'path'
---
>         'pathname'
1588c1592
<         'opath'
---
>         'oldname'
1592c1596
<         'npath'
---
>         'newname'
1604c1608
<         'path'
---
>         'pathname'
1616c1620
<         'opath'
---
>         'oldname'
1620c1624
<         'npath'
---
>         'newname'
1652c1656
<         'path'
---
>         'filename'
1684c1688
<         'path'
---
>         'filename'
1724c1728
<         'path'
---
>         'filename'
2277c2281
<         'path'
---
>         'filename'
2293c2297
<         'path'
---
>         'filename'
2346c2350
<         'path'
---
>         'pathname'
2427c2431
<   'sys_sched_setparam' => {
---
>   'sched_setparam' => {
2437c2441
<         'const void *',
---
>         'sched_param_p',
2459c2463
<   'sys_sched_setscheduler' => {
---
>   'sched_setscheduler' => {
2720c2724
<         'path'
---
>         'filename'
3064c3068
<         'path'
---
>         'pathname'
3092c3096
<         'path'
---
>         'pathname'
3148c3152
<         'path'
---
>         'pathname'
3172c3176
<         'path'
---
>         'pathname'
3220c3224
<         'path'
---
>         'pathname'
3240c3244
<         'path'
---
>         'pathname'
3280c3284
<         'path'
---
>         'pathname'
3296c3300
<         'path'
---
>         'pathname'
3381c3385
<   'sys_sched_setaffinity' => {
---
>   'sched_setaffinity' => {
3391c3395
<         'size_t',
---
>         'unsigned',
3395c3399
<         'const void *',
---
>         'uint64_p',
3401c3405
<   'sys_sched_getaffinity' => {
---
>   'sched_getaffinity' => {
3923c3927
<         'path'
---
>         'filename'
4327c4331
<         'path'
---
>         'pathname'
4387c4391
<         'path'
---
>         'filename'
4411c4415
<         'path'
---
>         'pathname'
4431c4435
<         'path'
---
>         'filename'
4455c4459
<         'path'
---
>         'filename'
4483c4487
<         'path'
---
>         'filename'
4503c4507
<         'path'
---
>         'filename'
4527c4531
<         'path'
---
>         'pathname'
4547c4551
<         'opath'
---
>         'oldname'
4555c4559
<         'npath'
---
>         'newname'
4571c4575
<         'opath'
---
>         'oldname'
4579c4583
<         'npath'
---
>         'newname'
4595c4599
<         'opath'
---
>         'oldname'
4603c4607
<         'npath'
---
>         'newname'
4619c4623
<         'path'
---
>         'pathname'
4643c4647
<         'path'
---
>         'filename'
4663c4667
<         'path'
---
>         'filename'
4738c4742
<         'int',
---
>         'uint64_t',
4927c4931
<         'path'
---
>         'filename'
5382,5383c5386,5387
<         'istr_t',
<         'path'
---
>         'long',
>         'pathname'
5547a5552,5555
>       ],
>       [
>         'uint64_t',
>         'unused'
5719c5727
<         'opath'
---
>         'oldname'
5727c5735
<         'npath'
---
>         'newname'
5851c5859
<         'path'
---
>         'filename'
Only in foo: syscall.pl
Only in main/: test.pl
Only in foo: tst

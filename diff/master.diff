diff '--color=auto' -r main/.git master/.git
1c1
< gitdir: /home/nn/src/git/hub/.git/worktrees/main
---
> gitdir: /home/nn/src/git/hub/.git/worktrees/master
diff '--color=auto' -r main/.gitignore master/.gitignore
1,6c1,2
< depends.mk
< bin/markout
< **.d
< **.[os]
< **.ii
< **.a
---
> **.[io][io]
> **.[dS]
9,10d4
< bin/report
< bin/string_view
18,19d11
< ,/bin/lspath
< bin/lspath
21a14
> hide
diff '--color=auto' -r main/Makefile master/Makefile
1,64c1,8
< MAKEFLAGS:= -rR -j24
< .EXPORT_ALL_VARIABLED:
< all:
< define dir_infer
< 
< $1/src:=  $(wildcard  $1/*.cc)                         
< $1/exe:=  $(patsubst  %.cc,%,   $($1/src))             
< $1/asm:=  $(wildcard  $1/*.S)                          
< $1/xxx:=  $(patsubst  %,%.o,   $($1/asm))             
< $1/exe+=  $(patsubst  %,%,      $($1/asm))             
< $1/obj:=  $(patsubst  %,%.o,   $($1/src))             
< $1/cpp:=  $(patsubst  %,%.ii,   $($1/src))             
< $1/dep:=  $(patsubst  %,%.d,    $($1/obj)   $($1/cpp)  $($1/asm))
< $1:=$($1/exe)
< endef
< $(call dir_infir,bin,lib) 
< 
< all/obj:= $(lib/obj) $(bin/obj)
< all/xxx:= $(lib/xxx) $(bin/xxx)
< all/cpp:= $(lib/cpp) $(bin/cpp)
< all/src:= $(lib/src) $(bin/src)
< all/dep:= $(lib/dep) $(bin/dep)
< 
< include /dev/null $(wildcard $(all/dep))
< 
< ext/obj:= $(filter-out $(all/obj), $(wildcard *.o))
< ext/xxx:= $(filter-out $(all/xxx), $(wildcard *.o))
< 
< all:= $(bin/exe) $(lib/lib)
< bin:= $(bin/exe)
< lib:= $(lib/lib)
< $(bin): $(lib)
< all: $(all)
< 
< include /dev/null $(wildcard $(all/dep))
< 
< $(lib/lib): $(lib/obj) $(lib/xxx)
< 	sbin/arch "$@" $(lib/obj) $(lib/xxx)
< 
< $(bin/exe): %: %.o sbin/link etc/ld_flags
< 	sbin/link "$@" $(lib/lib)
< 
< $(all/cpp): %.ii: %.cc sbin/prec etc/cppflags
< 	rm -f $*.ii $*.o
< 	sbin/prec "$@"
< 
< $(all/xxx): %.o: %.S sbin/casm etc/asmflags
< 	sbin/casm "$@"
< 
< $(all/obj): %.o: %.ii sbin/comp etc/cxxflags
< 	sbin/comp "$@"
< 
< cur/dep:=$(wildcard *.o.d)
< cur/obj:=$(wildcard *.o) $(patsubst %.d,%,$(cur/dep))
< cur/src:=$(patsubst %.o,%.cc,$(cur/obj))
< 
< 
< ifneq ($(have),$(want))
< $(lib/lib): rem-lib
< endif
< 
< ###   
< clean: date:=$(shell serdate)
< 
---
> MAKEFLAGS+= -rR
> SHELL:=/bin/bash
> all: lib bin tst
> 
> lib/lib:=lib/libkernpp.aa
> include etc/resolve.mk
> include etc/rules.mk
> clean_asm:=$(filter-out $(all/src/asm),$(all/mod/c++:=.S))
66c10,13
< 	rm -f */*.[ioad]
---
> 	rm -f */*.ii */*.oo */*.aa
> 	rm -f $(clean_asm)
> 	rm -f $(all/exe)
> 	ls -l $(all/src)
68,74c15,16
< $(all/obj): sbin/comp
< $(bin/exe): sbin/link
< $(lib/lib): sbin/arch
< $(bin/exe): $(lib)
< 
< tags: */*.cc */*.hh
< 	ctags --language-force=c++ */*.cc */*.hh
---
> all:
> 	@echo made all
76,77c18,25
< nm:
< 	nm */*.a */*.o --defined-only -A --demangle
---
> deps= $(sort $(wildcard */*.ii.d))
> cxxs= $(sort $(wildcard */*.cc))
> cpps= $(cxxs:.cc=.ii)
> xtra= $(filter-out $(cpps:=.d),$(deps)) $(filter-out $(deps:.d=),$(wildcard */*.ii))
> #show= $(foreach v,$1,$(warning SHOW $v=$($v)))
> #$(call show,deps cpps xtra intr)
> $(shell rm -f $(xtra))
> include /dev/null  $(filter-out $(xtra),$(wildcard */*.d))
diff '--color=auto' -r main/bin/.gitignore master/bin/.gitignore
9,15c9
< not
< cat
< echo
< false
< ls
< lspath
< not
---
> printenv
16a11
> runrep
18,20c13
< test_getopt
< true
< usleep
---
> touch
Only in main/bin: cat.cc
Only in main/bin: echo.cc
Only in main/bin: false.S
Only in main/bin: ls.cc
Only in main/bin: lspath.cc
Only in main/bin: not.cc
Only in master/bin: printenv.cc
diff '--color=auto' -r main/bin/report.cc master/bin/report.cc
1,61c1,63
< #include<syscall.hh>
< 
< //   #define wifexited(res) (wtermsig(res)==0)
< //   #define wtermsig(res) (res&0x7f)
< //   #define wexitstatus(res) ((res&0xff00)>>8)
< //   
< //   
< //   typedef char * str_t;
< //   typedef const char *str_c;
< //   
< //   int main(int argc, char** argv, char **envp)
< //   {
< //     if(argc<2) {
< //       write(2,"usage: ");
< //       write(2,argv[0]);
< //       write(2," <command>\n");
< //       return 2;
< //     };
< //     pid_t opid=sys::getpid();
< //     pid_t npid=xfork();
< //     int res;
< //     if(npid) {
< //       if(sys::wait(&res)<0){
< //         write(2,"wait: ");
< //         write(2,sys::strerror(sys::errno));
< //         write(2,"\n");
< //         return 1;
< //       };
< //   
< //       auto pos=argv;
< //       if(pos){
< //         if(*pos){
< //           write(2,*pos);
< //           while(*++pos){
< //             write(2," ");
< //             write(2,*pos);
< //           };
< //           write(2," returned ");
< //           write_dec(2,res);
< //           write(2,"\n");
< //           exit(res);
< //         };
< //       };
< //       if( wifexited(res) ) {
< //         res=wexitstatus(res);
< //         write(2,"returned ");
< //         write_dec(2,res);
< //         write(2,"\n");
< //         exit(res);
< //       } else {
< //         write(2,"sig: ");
< //         write_dec(2,wtermsig(res));
< //         write(2,"\n\n");
< //       };
< //     } else {
< //       ++argv;
< //       sys::execve(argv[0],argv, envp);
< //       return 0;
< //     };
< //     return res;
< //   };
---
> #include <syscall.hh>
> #include <search_path.hh>
> using shell_ns::search_path;
> using namespace sys;
> char **envp;
> template<typename val_t>
> void fmt(fd_t fd, val_t val);
> template<>
> void fmt<int>(fd_t fd, int val)
> {
>   static char buf[]="xxxxxxxxxxxxxxxx";
>   char *end=buf+sizeof(buf)-1;
>   if(val) {
>     while(val) {
>       *--end=(val%10)+'0';
>       val/=10;
>     };
>   } else {
>     *--end='0';
>   };
>   write(2,end);
> };
> extern istr_t *environ;
> template<>
> void fmt<const char*>(fd_t fd, const char * val)
> {
>   write(fd,val);
> }
> static char full[16*1024];
> using shell_ns::search_path;
> int main(int argc, char**argv, char**envp){
>   char *path=0;
>   bool abs=true;
>   if(!argv[1]) {
>     write(2,"No program provided\n");
>     exit(2);
>   };
>   const char *full=0;
>   full=search_path(argv[1],"PATH",false);
>   if(!full) {
>     write(2,"not found\n");
>     exit(97);
>   };
>   argv++;
>   pid_t pid=fork();
>   pid_t res;
>   if(pid) {
>     int ret;
>     do {
>       res=waitpid(0,&ret,0);
>       fmt(2,"pid ");
>       fmt(2,res);
>       fmt(2,"  returned ");
>       fmt(2,ret);
>       exit(ret/256);
>     } while(res>0);
>   } else {
>     execve(argv[0],argv,envp);
>     write(2,"execve:argv[0]");
>     exit(1);
>   }
>   return 0;
> };
Only in master/bin: runrep.cc
Only in main/bin: string_view.cc
Only in main/bin: test_getopt.cc
Only in master/bin: touch.cc
Only in master/bin: touch.help.inl
Only in main/bin: true.S
diff '--color=auto' -r main/bin/usleep.cc master/bin/usleep.cc
7a8
> using sys::exit;
18a20
> getopt_t getopt(0,0,0);
25c27
<   while ((opt = getopt(argc, argv, "sun")) != -1) {
---
>   while ((opt = getopt(argv)) != -1) {
62,71c64,73
<   if(optind<argc) {
<     tm.tv_nsec=atoi(argv[optind++]);
<     if(tm.tv_nsec >= billion){
<       tm.tv_sec=tm.tv_nsec/billion;
<       tm.tv_nsec=tm.tv_nsec%billion;
<     };
<   } else {
<     tm.tv_sec=1;
<     tm.tv_nsec=0;
<   };
---
> //     if(getopt.ind()<argc) {
> //       tm.tv_nsec=atoi(argv[getind++]);
> //       if(tm.tv_nsec >= billion){
> //         tm.tv_sec=tm.tv_nsec/billion;
> //         tm.tv_nsec=tm.tv_nsec%billion;
> //       };
> //     } else {
> //       tm.tv_sec=1;
> //       tm.tv_nsec=0;
> //     };
Only in main/: breakpoints
Only in master: cni
Only in main/: depends.pl
Only in master/doc: git-log.txt
Only in main/doc: lspath.bash
Only in master/doc: overview.md
Only in master/doc: touch.help
diff '--color=auto' -r main/etc/asmflags master/etc/asmflags
0a1
> -g -O0
diff '--color=auto' -r main/etc/cppflags master/etc/cppflags
2d1
< 
4a4,7
> -ffreestanding
> -fno-exceptions
> -ggdb3 -O0
> -fno-stack-protector
diff '--color=auto' -r main/etc/cxxflags master/etc/cxxflags
3,4c3
< -ggdb3
< -O0
---
> -ggdb3 -O0
5a5
> -std=c++20
diff '--color=auto' -r main/etc/ld_flags master/etc/ld_flags
1,2d0
< --freestanding
< -Bdynamic
4a3
> -Wl,--verbose
8c7
< -ggdb3 -O0
---
> -ggdb3
Only in master/etc: resolve.mk
Only in master/etc: rules.mk
Only in main/: files.md5
diff '--color=auto' -r main/inc/buf.hh master/inc/buf.hh
4a5
> #include <fmt.hh>
8a10
>   template<size_t _size>
10c12,16
<     buf_t()
---
>     static constexpr size_t size=_size;
>     int fd;
>     char buf[size];
>     buf_t(int fd=1)
>       :fd(fd)
16c22
<       sys::write(1,text,len);
---
>       sys::write(fd,text,len);
23c29
<       return __write(arg,strlen(arg));
---
>       return __write(arg,true_n(arg));
diff '--color=auto' -r main/inc/c_str.hh master/inc/c_str.hh
5c5,7
< 
---
> #include <dbg.hh>
> #include <cmp.hh>
> #include <itr.hh>
15a18,19
>   static const char colon[2];
>   static const char newline[2];
17,22c21,22
<   c_str()
<     : body((char*)null_str,(char*)null_str)
<   {
<   };
<   c_str(const char *b, const char *e = 0)
<     : body((char*)b,(char*)e)
---
>   c_str(char *b, char *e = 0)
>     :body(b,e)
24,28c24,27
<     if(body.end)
<       return;
<     body.end=body.beg;
<     while(*body.end)
<       ++body.end;
---
>     if(!body.beg)
>       body.end=0;
>     if(!body.end)
>       body.end=body.beg+true_n(body.beg);
30,31c29,30
<   c_str(char *b, char *e = 0)
<     : body(b,e)
---
>   c_str(const char *b=0, const char *e=0)
>     : body((char*)b,(char*)(e))
33,37d31
<     if(body.end)
<       return;
<     body.end=body.beg;
<     while(*body.end)
<       ++body.end;
46a41,45
>   template<size_t n>
>     c_str(char(b)[n], bool i)
>     :body(b,b+n-i?0:1)
>     {
>     }
94,97c93,98
<   static int cmp(size_t lhs, size_t rhs);
<   static int cmp(const c_str &lhs, const c_str &rhs);
<   static const c_str colon;
<   static const c_str newline;
---
>   friend auto cmp(const c_str &lhs, const c_str &rhs)
>   {
>     auto msize=min(lhs.size(),rhs.size());
>     auto r=seq_cmp(lhs.begin(),rhs.begin(),msize);
>     return r!=(0<=>0) ? r : (lhs.size()<=>rhs.size());
>   };
99,108d99
< #define cmp_op(x) \
<   inline bool operator x(const c_str &lhs, const c_str &rhs) { \
<     return c_str::cmp(lhs,rhs) x 0; \
<   };
< cmp_op(<);
< cmp_op(>);
< cmp_op(<=);
< cmp_op(>=);
< cmp_op(==);
< cmp_op(!=);
111c102
<   return sys::write(fd, str.begin(), str.size());
---
>   return sys::sys_write(fd, str.begin(), str.size());
Only in main/inc: char_traits.hh
Only in master/inc: cmp.hh
Only in main/inc: cxxabi.hh
diff '--color=auto' -r main/inc/errno.hh master/inc/errno.hh
44c44
<   typedef long errno_t;
---
>   typedef int errno_t;
46c46
<   ssize_t set_errno(errno_t err);
---
>   ssize_t set_errno(long err);
diff '--color=auto' -r main/inc/fmt.hh master/inc/fmt.hh
7c7
< #define AAI __attribute__((__always_inline__))
---
> #define AIL __attribute__((__always_inline__))
9c9
< #define AAI
---
> #define AIL
35c35
<   inline char *fmt_ptr(void *val, char *beg, char *end) {
---
>   inline char *fmt_ptr(const void *val, char *beg, char *end) {
53,54d52
<     if(neg)
<       *--end = '-';
61c59
<   inline int write_dec(fd_t fd, int val) {
---
>   inline int write_dec(fd_t fd, size_t val) {
63c61
<     return write(fd, fmt::fmt_dec(val<0,val<0?-val:val, buf, &buf[sizeof(buf) - 1]));
---
>     return write(fd, fmt::fmt_dec(false,val, buf, &buf[sizeof(buf) - 1]));
69c67
<   inline int write_ptr(fd_t fd, void *ptr) {
---
>   inline int write_ptr(fd_t fd, const void *ptr) {
71c69
<     return write(fd, fmt::fmt_ptr((void *)ptr, buf, &buf[sizeof(buf) - 1]));
---
>     return write(fd, fmt::fmt_ptr((const void *)ptr, buf, &buf[sizeof(buf) - 1]));
115c113
<           exit(1);
---
>           sys::exit(1);
119a118,137
> #define show_val(x) do_show_val(L(#x),(x))
> #define show_dec(x)                                                            \
>   do {                                                                         \
>     write(2, L(#x " => "));                                                    \
>     write_dec(2, (x));                                                         \
>     write(2, L("\n"));                                                         \
>   } while (false);
> #define show_ptr(x)                                                            \
>   do {                                                                         \
>     write(2, L(#x " => "));                                                    \
>     write_ptr(2, (x));                                                         \
>     write(2, L("\n"));                                                         \
>   } while (false);
> #define show_hex(x)                                                            \
>   do {                                                                         \
>     write(2, L(#x " => "));                                                    \
>     write_hex(2, (x));                                                         \
>     write(2, L("\n"));                                                         \
>   } while (false);
> #undef AAI
165c183
<     int fmt(void *vp)
---
>     int fmt(const void *vp)
diff '--color=auto' -r main/inc/getopt.hh master/inc/getopt.hh
1,15c1,31
< #ifndef GETOPT_HH
< #define GETOPT_HH GETOPT_HH
< 
< #define no_argument 1
< #define required_argument 2
< #define optional_argument 3
< 
< extern char* optarg;
< extern int optind, opterr, optopt;
< 
< struct option {
<   const char* name;
<   int has_arg;
<   int* flag;
<   int val;
---
> #pragma once
> struct option_t {
>   char buf[256];
>   int v1;
>   int v2;
>   int v3;
> };
> struct getopt_t {
>   struct body_t {
>     body_t(const char *str=0, option_t *b=0, option_t *e=0)
>     {
>     };
>   };
>   body_t body;
> 
>   getopt_t(const char *str=0, option_t *b=0, option_t *e=0)
>     :body(str,b,e)
>   {
>   };
>   template<size_t n>
>   getopt_t(const char *optstr, const option_t(&a)[n])
>   : body(optstr,a, a+n)
>   {
>   };
>   
>   int operator()(const char **argv) {
>     return 0;
>   };
>   int operator()(char **argv) {
>     return (*this)((const char**)argv);
>   };
18,24d33
< int getopt(int argc, char* const argv[], const char* optstring);
< 
< int getopt_long(int argc, char* const argv[],
<   const char* optstring, const struct option* longopts, int* longindex);
< 
< 
< #endif // INCLUDED_GETOPT_PORT_H
Only in master/inc: itr.hh
Only in main/inc: new.hh
Only in main/inc: ostream.hh
Only in main/inc: reverse_iterator.hh
Only in master/inc: search_path.hh
Only in main/inc: stdlib.hh
Only in main/inc: string_view.hh
diff '--color=auto' -r main/inc/syscall.hh master/inc/syscall.hh
8c8
< #define AAI __attribute__((__always_inline__))
---
> #define AIL __attribute__((__always_inline__))
11c11
< #define AAI
---
> #define AIL
52d51
< #include <stdlib.hh>
55c54
< #define chk_return(val) return set_errno(val);
---
> #define chk_return(val) return (val < 0 ? set_errno(val) : val)
60,67c59,72
<     inline int     nanosleep(timespec_p rqtp, timespec_p rmtp) AAI;
<     inline int     close(fd_t fd) AAI;
<     inline int     stat(const char* pathname, struct stat* statbuf) AAI;
<     inline fd_t    open(const char* pathname, open_flags  flags, open_mode   mode) AAI;
<     inline time_t  time(time_t*) AAI;
<     inline ssize_t getdents(fd_t fd, linux_dirent64* buf, size_t len) AAI;
<     inline ssize_t read(fd_t fd, char* buf, size_t len) AAI;
<     inline ssize_t write(fd_t fd, const char* buf, size_t len) AAI;
---
>     inline int     nanosleep(timespec_p rqtp, timespec_p rmtp) AIL;
>     inline int     close(fd_t fd) AIL;
>     inline int     stat(const char* pathname, struct stat_t* statbuf) AIL;
>     inline fd_t    open(const char* pathname,
>                         open_flags  flags,
>                         open_mode   mode) AIL;
>     inline time_t  time(time_t*) AIL;
>     inline ssize_t getdents(fd_t fd, linux_dirent64* buf, size_t len) AIL;
>     inline ssize_t read(fd_t fd, char* buf, size_t len) AIL;
>     inline ssize_t sys_write(fd_t fd, const char* buf, size_t len) AIL;
>     constexpr auto UTIME_NOW = (((1<<30)-1));
>     constexpr auto UTIME_OMIT = (((1<<30)-2));
>     constexpr auto AT_FDCWD=-100;
>     inline int utimensat(fd_t dfd, istr_t filename, timespec_p utimes, int flags) AIL;
82c87
<   inline ssize_t write(fd_t fd, const char* buf, size_t len)
---
>   inline ssize_t sys_write(fd_t fd, const char* buf, size_t len)
117c122
<   inline int stat(const char* pathname, struct stat* statbuf)
---
>   inline int stat(const char* pathname, struct stat_t* statbuf)
347d351
< // __NR__ exit = 60 
351,352d354
<     int exit_val;
<     exit_val= res & 0xff;
355c357
<         : "a"(60), "D"(exit_val)
---
>         : "a"(60), "D"(res)
358c360
<       ;
---
>       sleep(1);
448a451,466
>   // __NR__ utimensat = 280 
> //   //     inline int wait4(pid_t upid, int32_p stat_p, int opt, rusage_p ru)
>   inline int utimensat(fd_t dfd, istr_t filename, timespec_p utimes, int flags) AIL;
>   inline int utimensat(fd_t dfd, istr_t filename, timespec_p utimes, int flags)
>   {
> 
>     uint64_t res;
> 
>     __asm__ volatile(
>              "\tsyscall;\n"
>              : "=a"(res)
>              : "0"(200), "D"(dfd), "S"(filename), "d"(utimes), "g"(flags)
>              : "rcx", "memory", "r8", "r9");
> 
>     chk_return(res);
>   }
454,455c472,474
<   inline ssize_t write(int fd, const char* buf, const char* end) AAI;
<   inline ssize_t write(fd_t fd, const char* buf) AAI;
---
>   inline ssize_t write(int fd, const char* buf, size_t len) AIL;
>   inline ssize_t write(int fd, const char* buf, const char* end) AIL;
>   inline ssize_t write(fd_t fd, const char* buf) AIL;
456a476,479
>   inline ssize_t write(int fd, const char* buf, size_t len)
>   {
>     return sys_write(fd, buf, len);
>   }
459c482
<     return write(fd, buf, end - buf);
---
>     return sys_write(fd, buf, end - buf);
464c487
<     const char* end= buf ? buf : "(null)";
---
>     const char* end= buf;
467c490
<     return write(fd, buf, end - buf);
---
>     return sys_write(fd, buf, end - buf);
471c494
<     AAI;
---
>     AIL;
475c498
<     AAI;
---
>     AIL;
484c507
<       ssize_t res= write(fd, pos, end - pos);
---
>       ssize_t res= sys_write(fd, pos, end - pos);
511,515d533
<   using ::free;
<   using ::malloc;
<   using ::memset;
<   using ::realloc;
<   using ::size_t;
522,532d539
< extern "C"
< {
<   void        abort() __attribute__((__noreturn__));
<   inline void abort()
<   {
<     do
<     {
<       asm("int3");
<     } while(true);
<   }
< }
534c541
< #undef AAI
---
> #undef AIL
539,543d545
< 
< extern "C" {
<   int main(int argc, char**argv, char**envp);
< };
< 
Only in main/inc: tinfo.hh
Only in main/inc: typeinfo.hh
diff '--color=auto' -r main/inc/types.hh master/inc/types.hh
117c117
< struct statfs;
---
> struct statfs_t;
144c144
< struct stat;
---
> struct stat_t;
147c147
< typedef stat* stat_p;
---
> typedef stat_t * stat_p;
153c153
< typedef statfs* statfs_p;
---
> typedef statfs_t* statfs_p;
178c178
< typedef long errno_t;
---
> typedef int errno_t;
diff '--color=auto' -r main/inc/write_buf.hh master/inc/write_buf.hh
35c35
<     memset(buf, 0, end - buf);
---
>     set(buf, end, 0);
55c55
<     memset(&buf,0,end-buf);
---
>     set(buf,end,0);
diff '--color=auto' -r main/lib/abi.cc master/lib/abi.cc
4a5
>   using std::abort;
18d18
< 
Only in master/lib: algo.hh
diff '--color=auto' -r main/lib/c_str.cc master/lib/c_str.cc
2c2
< 
---
> #include <cmp.hh>
4,8c4,8
< const c_str c_str::colon=":";
< const c_str c_str::newline="\n";
< 
< int c_str::cmp(size_t lhs, size_t rhs) {
<   return lhs-rhs;
---
> const char c_str::colon[2]=":";
> const char c_str::newline[2]="\n";
> template<class t1>
> t1 min(t1 lhs, t1 rhs){
>   return (lhs<rhs)?lhs:rhs;
10,15c10,17
< int c_str::cmp(const c_str &lhs, const c_str &rhs)
< {
<   int res = cmp(lhs.len(),rhs.len());
<   if(!res)
<     res=strncmp(lhs.begin(),rhs.begin(),lhs.size());
<   return res;
---
> template<class i1_t, class i2_t>
> int icmp(i1_t b1, i1_t e1, i2_t b2, i2_t e2){
>   while(*b1 && *b2) {
>     b1++; b2++;
>     if(b1==e1 || b2==e1)
>       break;
>   };
>   return (b1==e1?-1:0)+(b2==e2?1:0);
Only in main/lib: cxxabi.cc
Only in main/lib: delete.cc
Only in main/lib: dyncast.cc
diff '--color=auto' -r main/lib/errno.cc master/lib/errno.cc
3c3
< #include <write_buf.hh>
---
> #include <buf.hh>
7c7
<   ssize_t set_errno(errno_t err)
---
>   ssize_t set_errno(ssize_t err)
10a11,16
>     {
>       buf_ns::buf_t<80> buf(2);
>       // XXX why is 11 a special case?
>       if(err!=11)
>         buf.println("setting error to=",err);
>     };
26c32
<     write_buf<> buf(2);
---
>     buf_ns::buf_t<256> buf(2);
28,29c34,35
<       buf.put(msg1);
<       buf.put(":");
---
>       buf.print(msg1);
>       buf.print(":");
32,33c38,39
<       buf.put(msg2);
<       buf.put(":");
---
>       buf.print(msg2);
>       buf.print(":");
35c41
<     buf.putln(strerror(errno));
---
>     buf.println(strerror(errno));
diff '--color=auto' -r main/lib/getopt.cc master/lib/getopt.cc
1,229c1,229
< /*******************************************************************************
<  * Copyright (c) 2012-2017, Kim Grasman <kim.grasman@gmail.com>
<  * All rights reserved.
<  *
<  * Redistribution and use in source and binary forms, with or without
<  * modification, are permitted provided that the following conditions are met:
<  *   * Redistributions of source code must retain the above copyright
<  *     notice, this list of conditions and the following disclaimer.
<  *   * Redistributions in binary form must reproduce the above copyright
<  *     notice, this list of conditions and the following disclaimer in the
<  *     documentation and/or other materials provided with the distribution.
<  *   * Neither the name of Kim Grasman nor the
<  *     names of contributors may be used to endorse or promote products
<  *     derived from this software without specific prior written permission.
<  *
<  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
<  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<  * ARE DISCLAIMED. IN NO EVENT SHALL KIM GRASMAN BE LIABLE FOR ANY
<  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
<  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
<  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
<  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<  *
<  ******************************************************************************/
< #include <syscall.hh>
< #include <getopt.hh>
< 
< //   #include <stddef.h>
< //   #include <string.h>
< 
< char* optarg;
< int optopt;
< /* The variable optind [...] shall be initialized to 1 by the system. */
< int optind = 1;
< int opterr;
< #define NULL nullptr
< 
< static char* optcursor = NULL;
< 
< /* Implemented based on [1] and [2] for optional arguments.
<    optopt is handled FreeBSD-style, per [3].
<    Other GNU and FreeBSD extensions are purely accidental.
< 
< [1] http://pubs.opengroup.org/onlinepubs/000095399/functions/getopt.html
< [2] http://www.kernel.org/doc/man-pages/online/pages/man3/getopt.3.html
< [3] http://www.freebsd.org/cgi/man.cgi?query=getopt&sektion=3&manpath=FreeBSD+9.0-RELEASE
< */
< int getopt(int argc, char* const argv[], const char* optstring) {
<   int optchar = -1;
<   const char* optdecl = NULL;
< 
<   optarg = NULL;
<   opterr = 0;
<   optopt = 0;
< 
<   /* Unspecified, but we need it to avoid overrunning the argv bounds. */
<   if (optind >= argc)
<     goto no_more_optchars;
< 
<   /* If, when getopt() is called argv[optind] is a null pointer, getopt()
<      shall return -1 without changing optind. */
<   if (argv[optind] == NULL)
<     goto no_more_optchars;
< 
<   /* If, when getopt() is called *argv[optind]  is not the character '-',
<      getopt() shall return -1 without changing optind. */
<   if (*argv[optind] != '-')
<     goto no_more_optchars;
< 
<   /* If, when getopt() is called argv[optind] points to the string "-",
<      getopt() shall return -1 without changing optind. */
<   if (strcmp(argv[optind], "-") == 0)
<     goto no_more_optchars;
< 
<   /* If, when getopt() is called argv[optind] points to the string "--",
<      getopt() shall return -1 after incrementing optind. */
<   if (strcmp(argv[optind], "--") == 0) {
<     ++optind;
<     goto no_more_optchars;
<   }
< 
<   if (optcursor == NULL || *optcursor == '\0')
<     optcursor = argv[optind] + 1;
< 
<   optchar = *optcursor;
< 
<   /* FreeBSD: The variable optopt saves the last known option character
<      returned by getopt(). */
<   optopt = optchar;
< 
<   /* The getopt() function shall return the next option character (if one is
<      found) from argv that matches a character in optstring, if there is
<      one that matches. */
<   optdecl = strchr(optstring, optchar);
<   if (optdecl) {
<     /* [I]f a character is followed by a colon, the option takes an
<        argument. */
<     if (optdecl[1] == ':') {
<       optarg = ++optcursor;
<       if (*optarg == '\0') {
<         /* GNU extension: Two colons mean an option takes an
<            optional arg; if there is text in the current argv-element
<            (i.e., in the same word as the option name itself, for example,
<            "-oarg"), then it is returned in optarg, otherwise optarg is set
<            to zero. */
<         if (optdecl[2] != ':') {
<           /* If the option was the last character in the string pointed to by
<              an element of argv, then optarg shall contain the next element
<              of argv, and optind shall be incremented by 2. If the resulting
<              value of optind is greater than argc, this indicates a missing
<              option-argument, and getopt() shall return an error indication.
< 
<              Otherwise, optarg shall point to the string following the
<              option character in that element of argv, and optind shall be
<              incremented by 1.
<           */
<           if (++optind < argc) {
<             optarg = argv[optind];
<           } else {
<             /* If it detects a missing option-argument, it shall return the
<                colon character ( ':' ) if the first character of optstring
<                was a colon, or a question-mark character ( '?' ) otherwise.
<             */
<             optarg = NULL;
<             optchar = (optstring[0] == ':') ? ':' : '?';
<           }
<         } else {
<           optarg = NULL;
<         }
<       }
< 
<       optcursor = NULL;
<     }
<   } else {
<     /* If getopt() encounters an option character that is not contained in
<        optstring, it shall return the question-mark ( '?' ) character. */
<     optchar = '?';
<   }
< 
<   if (optcursor == NULL || *++optcursor == '\0')
<     ++optind;
< 
<   return optchar;
< 
< no_more_optchars:
<   optcursor = NULL;
<   return -1;
< }
< 
< /* Implementation based on [1].
< 
< [1] http://www.kernel.org/doc/man-pages/online/pages/man3/getopt.3.html
< */
< int getopt_long(int argc, char* const argv[], const char* optstring,
<   const struct option* longopts, int* longindex) {
<   const struct option* o = longopts;
<   const struct option* match = NULL;
<   int num_matches = 0;
<   size_t argument_name_length = 0;
<   const char* current_argument = NULL;
<   int retval = -1;
< 
<   optarg = NULL;
<   optopt = 0;
< 
<   if (optind >= argc)
<     return -1;
< 
<   if (argv[optind][0]!='-' || argv[optind][1]!='-' || argv[optind][2]==0)
<     return getopt(argc, argv, optstring);
< 
<   /* It's an option; starts with -- and is longer than two chars. */
<   current_argument = argv[optind] + 2;
<   argument_name_length = strcspn(current_argument, "=");
<   for (; o->name; ++o) {
<     if (strncmp(o->name, current_argument, argument_name_length) == 0) {
<       match = o;
<       ++num_matches;
<     }
<   }
< 
<   if (num_matches == 1) {
<     /* If longindex is not NULL, it points to a variable which is set to the
<        index of the long option relative to longopts. */
<     if (longindex)
<       *longindex = (match - longopts);
< 
<     /* If flag is NULL, then getopt_long() shall return val.
<        Otherwise, getopt_long() returns 0, and flag shall point to a variable
<        which shall be set to val if the option is found, but left unchanged if
<        the option is not found. */
<     if (match->flag)
<       *(match->flag) = match->val;
< 
<     retval = match->flag ? 0 : match->val;
< 
<     if (match->has_arg != no_argument) {
<       optarg = (char*)strchr(argv[optind], '=');
<       if (optarg != NULL)
<         ++optarg;
< 
<       if (match->has_arg == required_argument) {
<         /* Only scan the next argv for required arguments. Behavior is not
<            specified, but has been observed with Ubuntu and Mac OSX. */
<         if (optarg == NULL && ++optind < argc) {
<           optarg = argv[optind];
<         }
< 
<         if (optarg == NULL)
<           retval = ':';
<       }
<     } else if (strchr(argv[optind], '=')) {
<       /* An argument was provided to a non-argument option.
<          I haven't seen this specified explicitly, but both GNU and BSD-based
<          implementations show this behavior.
<       */
<       retval = '?';
<     }
<   } else {
<     /* Unknown option or ambiguous match. */
<     retval = '?';
<   }
< 
<   ++optind;
<   return retval;
< }
---
> //  /*******************************************************************************
> //   * Copyright (c) 2012-2017, Kim Grasman <kim.grasman@gmail.com>
> //   * All rights reserved.
> //   *
> //   * Redistribution and use in source and binary forms, with or without
> //   * modification, are permitted provided that the following conditions are met:
> //   *   * Redistributions of source code must retain the above copyright
> //   *     notice, this list of conditions and the following disclaimer.
> //   *   * Redistributions in binary form must reproduce the above copyright
> //   *     notice, this list of conditions and the following disclaimer in the
> //   *     documentation and/or other materials provided with the distribution.
> //   *   * Neither the name of Kim Grasman nor the
> //   *     names of contributors may be used to endorse or promote products
> //   *     derived from this software without specific prior written permission.
> //   *
> //   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
> //   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
> //   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
> //   * ARE DISCLAIMED. IN NO EVENT SHALL KIM GRASMAN BE LIABLE FOR ANY
> //   * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
> //   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
> //   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
> //   * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
> //   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
> //   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
> //   *
> //   ******************************************************************************/
> //  #include <syscall.hh>
> //  #include <getopt.hh>
> //  
> //  //   #include <stddef.h>
> //  //   #include <string.h>
> //  
> //  char* optarg;
> //  int optopt;
> //  /* The variable optind [...] shall be initialized to 1 by the system. */
> //  int optind = 1;
> //  int opterr;
> //  #define NULL nullptr
> //  
> //  static char* optcursor = NULL;
> //  
> //  /* Implemented based on [1] and [2] for optional arguments.
> //     optopt is handled FreeBSD-style, per [3].
> //     Other GNU and FreeBSD extensions are purely accidental.
> //  
> //  [1] http://pubs.opengroup.org/onlinepubs/000095399/functions/getopt.html
> //  [2] http://www.kernel.org/doc/man-pages/online/pages/man3/getopt.3.html
> //  [3] http://www.freebsd.org/cgi/man.cgi?query=getopt&sektion=3&manpath=FreeBSD+9.0-RELEASE
> //  */
> //  int getopt(int argc, char* const argv[], const char* optstring) {
> //    int optchar = -1;
> //    const char* optdecl = NULL;
> //  
> //    optarg = NULL;
> //    opterr = 0;
> //    optopt = 0;
> //  
> //    /* Unspecified, but we need it to avoid overrunning the argv bounds. */
> //    if (optind >= argc)
> //      goto no_more_optchars;
> //  
> //    /* If, when getopt() is called argv[optind] is a null pointer, getopt()
> //       shall return -1 without changing optind. */
> //    if (argv[optind] == NULL)
> //      goto no_more_optchars;
> //  
> //    /* If, when getopt() is called *argv[optind]  is not the character '-',
> //       getopt() shall return -1 without changing optind. */
> //    if (*argv[optind] != '-')
> //      goto no_more_optchars;
> //  
> //    /* If, when getopt() is called argv[optind] points to the string "-",
> //       getopt() shall return -1 without changing optind. */
> //    if (strcmp(argv[optind], "-") == 0)
> //      goto no_more_optchars;
> //  
> //    /* If, when getopt() is called argv[optind] points to the string "--",
> //       getopt() shall return -1 after incrementing optind. */
> //    if (strcmp(argv[optind], "--") == 0) {
> //      ++optind;
> //      goto no_more_optchars;
> //    }
> //  
> //    if (optcursor == NULL || *optcursor == '\0')
> //      optcursor = argv[optind] + 1;
> //  
> //    optchar = *optcursor;
> //  
> //    /* FreeBSD: The variable optopt saves the last known option character
> //       returned by getopt(). */
> //    optopt = optchar;
> //  
> //    /* The getopt() function shall return the next option character (if one is
> //       found) from argv that matches a character in optstring, if there is
> //       one that matches. */
> //    optdecl = strchr(optstring, optchar);
> //    if (optdecl) {
> //      /* [I]f a character is followed by a colon, the option takes an
> //         argument. */
> //      if (optdecl[1] == ':') {
> //        optarg = ++optcursor;
> //        if (*optarg == '\0') {
> //          /* GNU extension: Two colons mean an option takes an
> //             optional arg; if there is text in the current argv-element
> //             (i.e., in the same word as the option name itself, for example,
> //             "-oarg"), then it is returned in optarg, otherwise optarg is set
> //             to zero. */
> //          if (optdecl[2] != ':') {
> //            /* If the option was the last character in the string pointed to by
> //               an element of argv, then optarg shall contain the next element
> //               of argv, and optind shall be incremented by 2. If the resulting
> //               value of optind is greater than argc, this indicates a missing
> //               option-argument, and getopt() shall return an error indication.
> //  
> //               Otherwise, optarg shall point to the string following the
> //               option character in that element of argv, and optind shall be
> //               incremented by 1.
> //            */
> //            if (++optind < argc) {
> //              optarg = argv[optind];
> //            } else {
> //              /* If it detects a missing option-argument, it shall return the
> //                 colon character ( ':' ) if the first character of optstring
> //                 was a colon, or a question-mark character ( '?' ) otherwise.
> //              */
> //              optarg = NULL;
> //              optchar = (optstring[0] == ':') ? ':' : '?';
> //            }
> //          } else {
> //            optarg = NULL;
> //          }
> //        }
> //  
> //        optcursor = NULL;
> //      }
> //    } else {
> //      /* If getopt() encounters an option character that is not contained in
> //         optstring, it shall return the question-mark ( '?' ) character. */
> //      optchar = '?';
> //    }
> //  
> //    if (optcursor == NULL || *++optcursor == '\0')
> //      ++optind;
> //  
> //    return optchar;
> //  
> //  no_more_optchars:
> //    optcursor = NULL;
> //    return -1;
> //  }
> //  
> //  /* Implementation based on [1].
> //  
> //  [1] http://www.kernel.org/doc/man-pages/online/pages/man3/getopt.3.html
> //  */
> //  int getopt_long(int argc, char* const argv[], const char* optstring,
> //    const struct option* longopts, int* longindex) {
> //    const struct option* o = longopts;
> //    const struct option* match = NULL;
> //    int num_matches = 0;
> //    size_t argument_name_length = 0;
> //    const char* current_argument = NULL;
> //    int retval = -1;
> //  
> //    optarg = NULL;
> //    optopt = 0;
> //  
> //    if (optind >= argc)
> //      return -1;
> //  
> //    if (strlen(argv[optind]) < 3 || strncmp(argv[optind], "--", 2) != 0)
> //      return getopt(argc, argv, optstring);
> //  
> //    /* It's an option; starts with -- and is longer than two chars. */
> //    current_argument = argv[optind] + 2;
> //    argument_name_length = strcspn(current_argument, "=");
> //    for (; o->name; ++o) {
> //      if (strncmp(o->name, current_argument, argument_name_length) == 0) {
> //        match = o;
> //        ++num_matches;
> //      }
> //    }
> //  
> //    if (num_matches == 1) {
> //      /* If longindex is not NULL, it points to a variable which is set to the
> //         index of the long option relative to longopts. */
> //      if (longindex)
> //        *longindex = (match - longopts);
> //  
> //      /* If flag is NULL, then getopt_long() shall return val.
> //         Otherwise, getopt_long() returns 0, and flag shall point to a variable
> //         which shall be set to val if the option is found, but left unchanged if
> //         the option is not found. */
> //      if (match->flag)
> //        *(match->flag) = match->val;
> //  
> //      retval = match->flag ? 0 : match->val;
> //  
> //      if (match->has_arg != no_argument) {
> //        optarg = (char*)strchr(argv[optind], '=');
> //        if (optarg != NULL)
> //          ++optarg;
> //  
> //        if (match->has_arg == required_argument) {
> //          /* Only scan the next argv for required arguments. Behavior is not
> //             specified, but has been observed with Ubuntu and Mac OSX. */
> //          if (optarg == NULL && ++optind < argc) {
> //            optarg = argv[optind];
> //          }
> //  
> //          if (optarg == NULL)
> //            retval = ':';
> //        }
> //      } else if (strchr(argv[optind], '=')) {
> //        /* An argument was provided to a non-argument option.
> //           I haven't seen this specified explicitly, but both GNU and BSD-based
> //           implementations show this behavior.
> //        */
> //        retval = '?';
> //      }
> //    } else {
> //      /* Unknown option or ambiguous match. */
> //      retval = '?';
> //    }
> //  
> //    ++optind;
> //    return retval;
> //  }
diff '--color=auto' -r main/lib/init_array.cc master/lib/init_array.cc
6c6,8
< 
---
> namespace shell_ns {
>   istr_t *environ;
> };
17c19
< inline ssize_t write( fd_t fd,  const char *buf,  size_t len)
---
> inline ssize_t write( fd_t fd,  istr_t buf,  size_t len)
143c145,146
< 	void libc_init() {
---
> 	void libc_init(int argc, istr_t *argv, istr_t *envp) {
>     shell_ns::environ=envp;
Only in main/lib: mm.cc
Only in main/lib: new.cc
Only in master/lib: search_path.cc
Only in main/lib: start.S
Only in main/lib: stdlib.cc
Only in main/lib: type_info.cc
diff '--color=auto' -r main/lib/write_buf.cc master/lib/write_buf.cc
2c2
< 
---
> #include <itr.hh>
9c9,10
<   char res[256];
---
>   char buf[255];
>   char end[1];
13c14
<     memset(res,0,sizeof(res));
---
>     set(buf,end,0);
16c17
<       res[*pos]=1;
---
>       buf[*pos]=1;
18c19
<     res['\n']=1;
---
>     buf['\n']=1;
22c23
<     return res[ch];
---
>     return buf[ch];
Only in master/sbin: gen-headers.pl
Only in master/sbin: gen-list.pl
Only in master/sbin: gen-strerror.pl
Only in master/sbin: gen-syscall.pl
Only in master/sbin: gen-utimevals.c
Only in main/sbin: genheaders.pl
Only in main/sbin: genlist.pl
Only in main/sbin: genstrerror.pl
Only in main/sbin: gensyscall.pl
Only in main/: script
Only in main/: test.pl
Only in master: tst

// #  0 "lib/errno.cc"
// #  1 "/home/nn/src/kernpp./main//"
// #  0 "<built-in>"
// # define __STDC__ 1
// #  0 "<built-in>"
// # define __cplusplus 202002L
// #  0 "<built-in>"
// # define __STDC_UTF_16__ 1
// #  0 "<built-in>"
// # define __STDC_UTF_32__ 1
// #  0 "<built-in>"
// # define __STDC_HOSTED__ 0
// #  0 "<built-in>"
// # define __GNUC__ 12
// #  0 "<built-in>"
// # define __GNUC_MINOR__ 2
// #  0 "<built-in>"
// # define __GNUC_PATCHLEVEL__ 0
// #  0 "<built-in>"
// # define __VERSION__ "12.2.0"
// #  0 "<built-in>"
// # define __ATOMIC_RELAXED 0
// #  0 "<built-in>"
// # define __ATOMIC_SEQ_CST 5
// #  0 "<built-in>"
// # define __ATOMIC_ACQUIRE 2
// #  0 "<built-in>"
// # define __ATOMIC_RELEASE 3
// #  0 "<built-in>"
// # define __ATOMIC_ACQ_REL 4
// #  0 "<built-in>"
// # define __ATOMIC_CONSUME 1
// #  0 "<built-in>"
// # define __pic__ 2
// #  0 "<built-in>"
// # define __PIC__ 2
// #  0 "<built-in>"
// # define __pie__ 2
// #  0 "<built-in>"
// # define __PIE__ 2
// #  0 "<built-in>"
// # define __FINITE_MATH_ONLY__ 0
// #  0 "<built-in>"
// # define _LP64 1
// #  0 "<built-in>"
// # define __LP64__ 1
// #  0 "<built-in>"
// # define __SIZEOF_INT__ 4
// #  0 "<built-in>"
// # define __SIZEOF_LONG__ 8
// #  0 "<built-in>"
// # define __SIZEOF_LONG_LONG__ 8
// #  0 "<built-in>"
// # define __SIZEOF_SHORT__ 2
// #  0 "<built-in>"
// # define __SIZEOF_FLOAT__ 4
// #  0 "<built-in>"
// # define __SIZEOF_DOUBLE__ 8
// #  0 "<built-in>"
// # define __SIZEOF_LONG_DOUBLE__ 16
// #  0 "<built-in>"
// # define __SIZEOF_SIZE_T__ 8
// #  0 "<built-in>"
// # define __CHAR_BIT__ 8
// #  0 "<built-in>"
// # define __BIGGEST_ALIGNMENT__ 16
// #  0 "<built-in>"
// # define __ORDER_LITTLE_ENDIAN__ 1234
// #  0 "<built-in>"
// # define __ORDER_BIG_ENDIAN__ 4321
// #  0 "<built-in>"
// # define __ORDER_PDP_ENDIAN__ 3412
// #  0 "<built-in>"
// # define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
// #  0 "<built-in>"
// # define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
// #  0 "<built-in>"
// # define __SIZEOF_POINTER__ 8
// #  0 "<built-in>"
// # define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
// #  0 "<built-in>"
// # define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
// #  0 "<built-in>"
// # define __GNUG__ 12
// #  0 "<built-in>"
// # define __SIZE_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __PTRDIFF_TYPE__ long int
// #  0 "<built-in>"
// # define __WCHAR_TYPE__ int
// #  0 "<built-in>"
// # define __WINT_TYPE__ unsigned int
// #  0 "<built-in>"
// # define __INTMAX_TYPE__ long int
// #  0 "<built-in>"
// # define __UINTMAX_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __CHAR8_TYPE__ unsigned char
// #  0 "<built-in>"
// # define __CHAR16_TYPE__ short unsigned int
// #  0 "<built-in>"
// # define __CHAR32_TYPE__ unsigned int
// #  0 "<built-in>"
// # define __SIG_ATOMIC_TYPE__ int
// #  0 "<built-in>"
// # define __INT8_TYPE__ signed char
// #  0 "<built-in>"
// # define __INT16_TYPE__ short int
// #  0 "<built-in>"
// # define __INT32_TYPE__ int
// #  0 "<built-in>"
// # define __INT64_TYPE__ long int
// #  0 "<built-in>"
// # define __UINT8_TYPE__ unsigned char
// #  0 "<built-in>"
// # define __UINT16_TYPE__ short unsigned int
// #  0 "<built-in>"
// # define __UINT32_TYPE__ unsigned int
// #  0 "<built-in>"
// # define __UINT64_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __INT_LEAST8_TYPE__ signed char
// #  0 "<built-in>"
// # define __INT_LEAST16_TYPE__ short int
// #  0 "<built-in>"
// # define __INT_LEAST32_TYPE__ int
// #  0 "<built-in>"
// # define __INT_LEAST64_TYPE__ long int
// #  0 "<built-in>"
// # define __UINT_LEAST8_TYPE__ unsigned char
// #  0 "<built-in>"
// # define __UINT_LEAST16_TYPE__ short unsigned int
// #  0 "<built-in>"
// # define __UINT_LEAST32_TYPE__ unsigned int
// #  0 "<built-in>"
// # define __UINT_LEAST64_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __INT_FAST8_TYPE__ signed char
// #  0 "<built-in>"
// # define __INT_FAST16_TYPE__ long int
// #  0 "<built-in>"
// # define __INT_FAST32_TYPE__ long int
// #  0 "<built-in>"
// # define __INT_FAST64_TYPE__ long int
// #  0 "<built-in>"
// # define __UINT_FAST8_TYPE__ unsigned char
// #  0 "<built-in>"
// # define __UINT_FAST16_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __UINT_FAST32_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __UINT_FAST64_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __INTPTR_TYPE__ long int
// #  0 "<built-in>"
// # define __UINTPTR_TYPE__ long unsigned int
// #  0 "<built-in>"
// # define __GXX_WEAK__ 1
// #  0 "<built-in>"
// # define __DEPRECATED 1
// #  0 "<built-in>"
// # define __GXX_RTTI 1
// #  0 "<built-in>"
// # define __cpp_rtti 199711L
// #  0 "<built-in>"
// # define __GXX_EXPERIMENTAL_CXX0X__ 1
// #  0 "<built-in>"
// # define __cpp_binary_literals 201304L
// #  0 "<built-in>"
// # define __cpp_hex_float 201603L
// #  0 "<built-in>"
// # define __cpp_runtime_arrays 198712L
// #  0 "<built-in>"
// # define __cpp_raw_strings 200710L
// #  0 "<built-in>"
// # define __cpp_unicode_literals 200710L
// #  0 "<built-in>"
// # define __cpp_user_defined_literals 200809L
// #  0 "<built-in>"
// # define __cpp_lambdas 200907L
// #  0 "<built-in>"
// # define __cpp_decltype 200707L
// #  0 "<built-in>"
// # define __cpp_attributes 200809L
// #  0 "<built-in>"
// # define __cpp_rvalue_reference 200610L
// #  0 "<built-in>"
// # define __cpp_rvalue_references 200610L
// #  0 "<built-in>"
// # define __cpp_variadic_templates 200704L
// #  0 "<built-in>"
// # define __cpp_initializer_lists 200806L
// #  0 "<built-in>"
// # define __cpp_delegating_constructors 200604L
// #  0 "<built-in>"
// # define __cpp_nsdmi 200809L
// #  0 "<built-in>"
// # define __cpp_inheriting_constructors 201511L
// #  0 "<built-in>"
// # define __cpp_ref_qualifiers 200710L
// #  0 "<built-in>"
// # define __cpp_alias_templates 200704L
// #  0 "<built-in>"
// # define __cpp_return_type_deduction 201304L
// #  0 "<built-in>"
// # define __cpp_decltype_auto 201304L
// #  0 "<built-in>"
// # define __cpp_aggregate_nsdmi 201304L
// #  0 "<built-in>"
// # define __cpp_variable_templates 201304L
// #  0 "<built-in>"
// # define __cpp_digit_separators 201309L
// #  0 "<built-in>"
// # define __cpp_unicode_characters 201411L
// #  0 "<built-in>"
// # define __cpp_static_assert 201411L
// #  0 "<built-in>"
// # define __cpp_namespace_attributes 201411L
// #  0 "<built-in>"
// # define __cpp_enumerator_attributes 201411L
// #  0 "<built-in>"
// # define __cpp_nested_namespace_definitions 201411L
// #  0 "<built-in>"
// # define __cpp_fold_expressions 201603L
// #  0 "<built-in>"
// # define __cpp_range_based_for 201603L
// #  0 "<built-in>"
// # define __cpp_if_constexpr 201606L
// #  0 "<built-in>"
// # define __cpp_capture_star_this 201603L
// #  0 "<built-in>"
// # define __cpp_inline_variables 201606L
// #  0 "<built-in>"
// # define __cpp_aggregate_bases 201603L
// #  0 "<built-in>"
// # define __cpp_noexcept_function_type 201510L
// #  0 "<built-in>"
// # define __cpp_template_auto 201606L
// #  0 "<built-in>"
// # define __cpp_structured_bindings 201606L
// #  0 "<built-in>"
// # define __cpp_variadic_using 201611L
// #  0 "<built-in>"
// # define __cpp_guaranteed_copy_elision 201606L
// #  0 "<built-in>"
// # define __cpp_nontype_template_parameter_auto 201606L
// #  0 "<built-in>"
// # define __cpp_init_captures 201803L
// #  0 "<built-in>"
// # define __cpp_generic_lambdas 201707L
// #  0 "<built-in>"
// # define __cpp_designated_initializers 201707L
// #  0 "<built-in>"
// # define __cpp_constexpr 202002L
// #  0 "<built-in>"
// # define __cpp_constexpr_in_decltype 201711L
// #  0 "<built-in>"
// # define __cpp_conditional_explicit 201806L
// #  0 "<built-in>"
// # define __cpp_consteval 201811L
// #  0 "<built-in>"
// # define __cpp_constinit 201907L
// #  0 "<built-in>"
// # define __cpp_deduction_guides 201907L
// #  0 "<built-in>"
// # define __cpp_nontype_template_args 201911L
// #  0 "<built-in>"
// # define __cpp_nontype_template_parameter_class 201806L
// #  0 "<built-in>"
// # define __cpp_impl_destroying_delete 201806L
// #  0 "<built-in>"
// # define __cpp_constexpr_dynamic_alloc 201907L
// #  0 "<built-in>"
// # define __cpp_impl_three_way_comparison 201907L
// #  0 "<built-in>"
// # define __cpp_aggregate_paren_init 201902L
// #  0 "<built-in>"
// # define __cpp_using_enum 201907L
// #  0 "<built-in>"
// # define __cpp_concepts 202002L
// #  0 "<built-in>"
// # define __cpp_impl_coroutine 201902L
// #  0 "<built-in>"
// # define __cpp_sized_deallocation 201309L
// #  0 "<built-in>"
// # define __cpp_aligned_new 201606L
// #  0 "<built-in>"
// # define __STDCPP_DEFAULT_NEW_ALIGNMENT__ 16
// #  0 "<built-in>"
// # define __cpp_template_template_args 201611L
// #  0 "<built-in>"
// # define __cpp_threadsafe_static_init 200806L
// #  0 "<built-in>"
// # define __cpp_char8_t 201811L
// #  0 "<built-in>"
// # define __STDCPP_THREADS__ 1
// #  0 "<built-in>"
// # define __GXX_ABI_VERSION 1017
// #  0 "<built-in>"
// # define __SCHAR_MAX__ 0x7f
// #  0 "<built-in>"
// # define __SHRT_MAX__ 0x7fff
// #  0 "<built-in>"
// # define __INT_MAX__ 0x7fffffff
// #  0 "<built-in>"
// # define __LONG_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
// #  0 "<built-in>"
// # define __WCHAR_MAX__ 0x7fffffff
// #  0 "<built-in>"
// # define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
// #  0 "<built-in>"
// # define __WINT_MAX__ 0xffffffffU
// #  0 "<built-in>"
// # define __WINT_MIN__ 0U
// #  0 "<built-in>"
// # define __PTRDIFF_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __SIZE_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __SCHAR_WIDTH__ 8
// #  0 "<built-in>"
// # define __SHRT_WIDTH__ 16
// #  0 "<built-in>"
// # define __INT_WIDTH__ 32
// #  0 "<built-in>"
// # define __LONG_WIDTH__ 64
// #  0 "<built-in>"
// # define __LONG_LONG_WIDTH__ 64
// #  0 "<built-in>"
// # define __WCHAR_WIDTH__ 32
// #  0 "<built-in>"
// # define __WINT_WIDTH__ 32
// #  0 "<built-in>"
// # define __PTRDIFF_WIDTH__ 64
// #  0 "<built-in>"
// # define __SIZE_WIDTH__ 64
// #  0 "<built-in>"
// # define __INTMAX_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __INTMAX_C(c) c ## L
// #  0 "<built-in>"
// # define __UINTMAX_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __UINTMAX_C(c) c ## UL
// #  0 "<built-in>"
// # define __INTMAX_WIDTH__ 64
// #  0 "<built-in>"
// # define __SIG_ATOMIC_MAX__ 0x7fffffff
// #  0 "<built-in>"
// # define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
// #  0 "<built-in>"
// # define __SIG_ATOMIC_WIDTH__ 32
// #  0 "<built-in>"
// # define __INT8_MAX__ 0x7f
// #  0 "<built-in>"
// # define __INT16_MAX__ 0x7fff
// #  0 "<built-in>"
// # define __INT32_MAX__ 0x7fffffff
// #  0 "<built-in>"
// # define __INT64_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __UINT8_MAX__ 0xff
// #  0 "<built-in>"
// # define __UINT16_MAX__ 0xffff
// #  0 "<built-in>"
// # define __UINT32_MAX__ 0xffffffffU
// #  0 "<built-in>"
// # define __UINT64_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __INT_LEAST8_MAX__ 0x7f
// #  0 "<built-in>"
// # define __INT8_C(c) c
// #  0 "<built-in>"
// # define __INT_LEAST8_WIDTH__ 8
// #  0 "<built-in>"
// # define __INT_LEAST16_MAX__ 0x7fff
// #  0 "<built-in>"
// # define __INT16_C(c) c
// #  0 "<built-in>"
// # define __INT_LEAST16_WIDTH__ 16
// #  0 "<built-in>"
// # define __INT_LEAST32_MAX__ 0x7fffffff
// #  0 "<built-in>"
// # define __INT32_C(c) c
// #  0 "<built-in>"
// # define __INT_LEAST32_WIDTH__ 32
// #  0 "<built-in>"
// # define __INT_LEAST64_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __INT64_C(c) c ## L
// #  0 "<built-in>"
// # define __INT_LEAST64_WIDTH__ 64
// #  0 "<built-in>"
// # define __UINT_LEAST8_MAX__ 0xff
// #  0 "<built-in>"
// # define __UINT8_C(c) c
// #  0 "<built-in>"
// # define __UINT_LEAST16_MAX__ 0xffff
// #  0 "<built-in>"
// # define __UINT16_C(c) c
// #  0 "<built-in>"
// # define __UINT_LEAST32_MAX__ 0xffffffffU
// #  0 "<built-in>"
// # define __UINT32_C(c) c ## U
// #  0 "<built-in>"
// # define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __UINT64_C(c) c ## UL
// #  0 "<built-in>"
// # define __INT_FAST8_MAX__ 0x7f
// #  0 "<built-in>"
// # define __INT_FAST8_WIDTH__ 8
// #  0 "<built-in>"
// # define __INT_FAST16_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __INT_FAST16_WIDTH__ 64
// #  0 "<built-in>"
// # define __INT_FAST32_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __INT_FAST32_WIDTH__ 64
// #  0 "<built-in>"
// # define __INT_FAST64_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __INT_FAST64_WIDTH__ 64
// #  0 "<built-in>"
// # define __UINT_FAST8_MAX__ 0xff
// #  0 "<built-in>"
// # define __UINT_FAST16_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __UINT_FAST32_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __UINT_FAST64_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __INTPTR_MAX__ 0x7fffffffffffffffL
// #  0 "<built-in>"
// # define __INTPTR_WIDTH__ 64
// #  0 "<built-in>"
// # define __UINTPTR_MAX__ 0xffffffffffffffffUL
// #  0 "<built-in>"
// # define __GCC_IEC_559 2
// #  0 "<built-in>"
// # define __GCC_IEC_559_COMPLEX 2
// #  0 "<built-in>"
// # define __FLT_EVAL_METHOD__ 0
// #  0 "<built-in>"
// # define __FLT_EVAL_METHOD_TS_18661_3__ 0
// #  0 "<built-in>"
// # define __DEC_EVAL_METHOD__ 2
// #  0 "<built-in>"
// # define __FLT_RADIX__ 2
// #  0 "<built-in>"
// # define __FLT_MANT_DIG__ 24
// #  0 "<built-in>"
// # define __FLT_DIG__ 6
// #  0 "<built-in>"
// # define __FLT_MIN_EXP__ (-125)
// #  0 "<built-in>"
// # define __FLT_MIN_10_EXP__ (-37)
// #  0 "<built-in>"
// # define __FLT_MAX_EXP__ 128
// #  0 "<built-in>"
// # define __FLT_MAX_10_EXP__ 38
// #  0 "<built-in>"
// # define __FLT_DECIMAL_DIG__ 9
// #  0 "<built-in>"
// # define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
// #  0 "<built-in>"
// # define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
// #  0 "<built-in>"
// # define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
// #  0 "<built-in>"
// # define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
// #  0 "<built-in>"
// # define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
// #  0 "<built-in>"
// # define __FLT_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __FLT_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __FLT_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __FLT_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __DBL_MANT_DIG__ 53
// #  0 "<built-in>"
// # define __DBL_DIG__ 15
// #  0 "<built-in>"
// # define __DBL_MIN_EXP__ (-1021)
// #  0 "<built-in>"
// # define __DBL_MIN_10_EXP__ (-307)
// #  0 "<built-in>"
// # define __DBL_MAX_EXP__ 1024
// #  0 "<built-in>"
// # define __DBL_MAX_10_EXP__ 308
// #  0 "<built-in>"
// # define __DBL_DECIMAL_DIG__ 17
// #  0 "<built-in>"
// # define __DBL_MAX__ double(1.79769313486231570814527423731704357e+308L)
// #  0 "<built-in>"
// # define __DBL_NORM_MAX__ double(1.79769313486231570814527423731704357e+308L)
// #  0 "<built-in>"
// # define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
// #  0 "<built-in>"
// # define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
// #  0 "<built-in>"
// # define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
// #  0 "<built-in>"
// # define __DBL_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __DBL_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __DBL_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __DBL_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __LDBL_MANT_DIG__ 64
// #  0 "<built-in>"
// # define __LDBL_DIG__ 18
// #  0 "<built-in>"
// # define __LDBL_MIN_EXP__ (-16381)
// #  0 "<built-in>"
// # define __LDBL_MIN_10_EXP__ (-4931)
// #  0 "<built-in>"
// # define __LDBL_MAX_EXP__ 16384
// #  0 "<built-in>"
// # define __LDBL_MAX_10_EXP__ 4932
// #  0 "<built-in>"
// # define __DECIMAL_DIG__ 21
// #  0 "<built-in>"
// # define __LDBL_DECIMAL_DIG__ 21
// #  0 "<built-in>"
// # define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
// #  0 "<built-in>"
// # define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
// #  0 "<built-in>"
// # define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
// #  0 "<built-in>"
// # define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
// #  0 "<built-in>"
// # define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
// #  0 "<built-in>"
// # define __LDBL_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __LDBL_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __LDBL_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __LDBL_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __FLT16_MANT_DIG__ 11
// #  0 "<built-in>"
// # define __FLT16_DIG__ 3
// #  0 "<built-in>"
// # define __FLT16_MIN_EXP__ (-13)
// #  0 "<built-in>"
// # define __FLT16_MIN_10_EXP__ (-4)
// #  0 "<built-in>"
// # define __FLT16_MAX_EXP__ 16
// #  0 "<built-in>"
// # define __FLT16_MAX_10_EXP__ 4
// #  0 "<built-in>"
// # define __FLT16_DECIMAL_DIG__ 5
// #  0 "<built-in>"
// # define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16
// #  0 "<built-in>"
// # define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16
// #  0 "<built-in>"
// # define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16
// #  0 "<built-in>"
// # define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16
// #  0 "<built-in>"
// # define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16
// #  0 "<built-in>"
// # define __FLT16_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __FLT16_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __FLT16_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __FLT16_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __FLT32_MANT_DIG__ 24
// #  0 "<built-in>"
// # define __FLT32_DIG__ 6
// #  0 "<built-in>"
// # define __FLT32_MIN_EXP__ (-125)
// #  0 "<built-in>"
// # define __FLT32_MIN_10_EXP__ (-37)
// #  0 "<built-in>"
// # define __FLT32_MAX_EXP__ 128
// #  0 "<built-in>"
// # define __FLT32_MAX_10_EXP__ 38
// #  0 "<built-in>"
// # define __FLT32_DECIMAL_DIG__ 9
// #  0 "<built-in>"
// # define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
// #  0 "<built-in>"
// # define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
// #  0 "<built-in>"
// # define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
// #  0 "<built-in>"
// # define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
// #  0 "<built-in>"
// # define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
// #  0 "<built-in>"
// # define __FLT32_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __FLT32_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __FLT32_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __FLT32_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __FLT64_MANT_DIG__ 53
// #  0 "<built-in>"
// # define __FLT64_DIG__ 15
// #  0 "<built-in>"
// # define __FLT64_MIN_EXP__ (-1021)
// #  0 "<built-in>"
// # define __FLT64_MIN_10_EXP__ (-307)
// #  0 "<built-in>"
// # define __FLT64_MAX_EXP__ 1024
// #  0 "<built-in>"
// # define __FLT64_MAX_10_EXP__ 308
// #  0 "<built-in>"
// # define __FLT64_DECIMAL_DIG__ 17
// #  0 "<built-in>"
// # define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
// #  0 "<built-in>"
// # define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
// #  0 "<built-in>"
// # define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
// #  0 "<built-in>"
// # define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
// #  0 "<built-in>"
// # define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
// #  0 "<built-in>"
// # define __FLT64_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __FLT64_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __FLT64_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __FLT64_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __FLT128_MANT_DIG__ 113
// #  0 "<built-in>"
// # define __FLT128_DIG__ 33
// #  0 "<built-in>"
// # define __FLT128_MIN_EXP__ (-16381)
// #  0 "<built-in>"
// # define __FLT128_MIN_10_EXP__ (-4931)
// #  0 "<built-in>"
// # define __FLT128_MAX_EXP__ 16384
// #  0 "<built-in>"
// # define __FLT128_MAX_10_EXP__ 4932
// #  0 "<built-in>"
// # define __FLT128_DECIMAL_DIG__ 36
// #  0 "<built-in>"
// # define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
// #  0 "<built-in>"
// # define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
// #  0 "<built-in>"
// # define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
// #  0 "<built-in>"
// # define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
// #  0 "<built-in>"
// # define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
// #  0 "<built-in>"
// # define __FLT128_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __FLT128_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __FLT128_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __FLT128_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __FLT32X_MANT_DIG__ 53
// #  0 "<built-in>"
// # define __FLT32X_DIG__ 15
// #  0 "<built-in>"
// # define __FLT32X_MIN_EXP__ (-1021)
// #  0 "<built-in>"
// # define __FLT32X_MIN_10_EXP__ (-307)
// #  0 "<built-in>"
// # define __FLT32X_MAX_EXP__ 1024
// #  0 "<built-in>"
// # define __FLT32X_MAX_10_EXP__ 308
// #  0 "<built-in>"
// # define __FLT32X_DECIMAL_DIG__ 17
// #  0 "<built-in>"
// # define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
// #  0 "<built-in>"
// # define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
// #  0 "<built-in>"
// # define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
// #  0 "<built-in>"
// # define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
// #  0 "<built-in>"
// # define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
// #  0 "<built-in>"
// # define __FLT32X_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __FLT32X_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __FLT32X_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __FLT32X_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __FLT64X_MANT_DIG__ 64
// #  0 "<built-in>"
// # define __FLT64X_DIG__ 18
// #  0 "<built-in>"
// # define __FLT64X_MIN_EXP__ (-16381)
// #  0 "<built-in>"
// # define __FLT64X_MIN_10_EXP__ (-4931)
// #  0 "<built-in>"
// # define __FLT64X_MAX_EXP__ 16384
// #  0 "<built-in>"
// # define __FLT64X_MAX_10_EXP__ 4932
// #  0 "<built-in>"
// # define __FLT64X_DECIMAL_DIG__ 21
// #  0 "<built-in>"
// # define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
// #  0 "<built-in>"
// # define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
// #  0 "<built-in>"
// # define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
// #  0 "<built-in>"
// # define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
// #  0 "<built-in>"
// # define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
// #  0 "<built-in>"
// # define __FLT64X_HAS_DENORM__ 1
// #  0 "<built-in>"
// # define __FLT64X_HAS_INFINITY__ 1
// #  0 "<built-in>"
// # define __FLT64X_HAS_QUIET_NAN__ 1
// #  0 "<built-in>"
// # define __FLT64X_IS_IEC_60559__ 2
// #  0 "<built-in>"
// # define __DEC32_MANT_DIG__ 7
// #  0 "<built-in>"
// # define __DEC32_MIN_EXP__ (-94)
// #  0 "<built-in>"
// # define __DEC32_MAX_EXP__ 97
// #  0 "<built-in>"
// # define __DEC32_MIN__ 1E-95DF
// #  0 "<built-in>"
// # define __DEC32_MAX__ 9.999999E96DF
// #  0 "<built-in>"
// # define __DEC32_EPSILON__ 1E-6DF
// #  0 "<built-in>"
// # define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
// #  0 "<built-in>"
// # define __DEC64_MANT_DIG__ 16
// #  0 "<built-in>"
// # define __DEC64_MIN_EXP__ (-382)
// #  0 "<built-in>"
// # define __DEC64_MAX_EXP__ 385
// #  0 "<built-in>"
// # define __DEC64_MIN__ 1E-383DD
// #  0 "<built-in>"
// # define __DEC64_MAX__ 9.999999999999999E384DD
// #  0 "<built-in>"
// # define __DEC64_EPSILON__ 1E-15DD
// #  0 "<built-in>"
// # define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
// #  0 "<built-in>"
// # define __DEC128_MANT_DIG__ 34
// #  0 "<built-in>"
// # define __DEC128_MIN_EXP__ (-6142)
// #  0 "<built-in>"
// # define __DEC128_MAX_EXP__ 6145
// #  0 "<built-in>"
// # define __DEC128_MIN__ 1E-6143DL
// #  0 "<built-in>"
// # define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
// #  0 "<built-in>"
// # define __DEC128_EPSILON__ 1E-33DL
// #  0 "<built-in>"
// # define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
// #  0 "<built-in>"
// # define __REGISTER_PREFIX__ 
// #  0 "<built-in>"
// # define __USER_LABEL_PREFIX__ 
// #  0 "<built-in>"
// # define __GNUC_STDC_INLINE__ 1
// #  0 "<built-in>"
// # define __NO_INLINE__ 1
// #  0 "<built-in>"
// # define __STRICT_ANSI__ 1
// #  0 "<built-in>"
// # define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
// #  0 "<built-in>"
// # define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
// #  0 "<built-in>"
// # define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
// #  0 "<built-in>"
// # define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
// #  0 "<built-in>"
// # define __GCC_ATOMIC_BOOL_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_CHAR_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_CHAR8_T_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_SHORT_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_INT_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_LONG_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_LLONG_LOCK_FREE 2
// #  0 "<built-in>"
// # define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
// #  0 "<built-in>"
// # define __GCC_DESTRUCTIVE_SIZE 64
// #  0 "<built-in>"
// # define __GCC_CONSTRUCTIVE_SIZE 64
// #  0 "<built-in>"
// # define __GCC_ATOMIC_POINTER_LOCK_FREE 2
// #  0 "<built-in>"
// # define __HAVE_SPECULATION_SAFE_VALUE 1
// #  0 "<built-in>"
// # define __GCC_HAVE_DWARF2_CFI_ASM 1
// #  0 "<built-in>"
// # define __PRAGMA_REDEFINE_EXTNAME 1
// #  0 "<built-in>"
// # define __SIZEOF_INT128__ 16
// #  0 "<built-in>"
// # define __SIZEOF_WCHAR_T__ 4
// #  0 "<built-in>"
// # define __SIZEOF_WINT_T__ 4
// #  0 "<built-in>"
// # define __SIZEOF_PTRDIFF_T__ 8
// #  0 "<built-in>"
// # define __amd64 1
// #  0 "<built-in>"
// # define __amd64__ 1
// #  0 "<built-in>"
// # define __x86_64 1
// #  0 "<built-in>"
// # define __x86_64__ 1
// #  0 "<built-in>"
// # define __SIZEOF_FLOAT80__ 16
// #  0 "<built-in>"
// # define __SIZEOF_FLOAT128__ 16
// #  0 "<built-in>"
// # define __ATOMIC_HLE_ACQUIRE 65536
// #  0 "<built-in>"
// # define __ATOMIC_HLE_RELEASE 131072
// #  0 "<built-in>"
// # define __GCC_ASM_FLAG_OUTPUTS__ 1
// #  0 "<built-in>"
// # define __k8 1
// #  0 "<built-in>"
// # define __k8__ 1
// #  0 "<built-in>"
// # define __code_model_small__ 1
// #  0 "<built-in>"
// # define __MMX__ 1
// #  0 "<built-in>"
// # define __SSE__ 1
// #  0 "<built-in>"
// # define __SSE2__ 1
// #  0 "<built-in>"
// # define __FXSR__ 1
// #  0 "<built-in>"
// # define __SSE_MATH__ 1
// #  0 "<built-in>"
// # define __SSE2_MATH__ 1
// #  0 "<built-in>"
// # define __MMX_WITH_SSE__ 1
// #  0 "<built-in>"
// # define __SEG_FS 1
// #  0 "<built-in>"
// # define __SEG_GS 1
// #  0 "<built-in>"
// # define __gnu_linux__ 1
// #  0 "<built-in>"
// # define __linux 1
// #  0 "<built-in>"
// # define __linux__ 1
// #  0 "<built-in>"
// # define __unix 1
// #  0 "<built-in>"
// # define __unix__ 1
// #  0 "<built-in>"
// # define __ELF__ 1
// #  0 "<built-in>"
// # define __DECIMAL_BID_FORMAT__ 1
// #  0 "<command-line>"
// # define _GNU_SOURCE 1
// #  1 "lib/errno.cc"
// #  1 "inc/syscall.hh" 1
       

// #  1 "inc/errno.hh" 1
       

// #  1 "inc/types.hh" 1

// # define types_hh types_hh

template<class T>
struct wrap_t {
  using val_t=T;
  val_t val;
  wrap_t(const val_t &val)
    :val(val)
  {
  }
  wrap_t(const wrap_t &rhs)
    : val(rhs.val)
  {
  }
  operator val_t&() {
    return val;
  };
  operator val_t() const {
    return val;
  };
};
typedef char* ostr_t;
typedef const char* istr_t;
typedef istr_t istr_v[];
typedef istr_t *istr_p;
typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef int int32_t;
typedef int32_t* int32_p;
typedef long int64_t;
typedef unsigned uint32_t;
typedef uint32_t* uint32_p;
typedef unsigned long uint64_t;
typedef uint64_t* uint64_p;
typedef unsigned short int uint16_t;
typedef void* void_p;

struct iocb;
typedef long int __fd_mask;
namespace sys {
  struct fdset_t;
  typedef fdset_t* fdset_p;
};




struct sigaction_t {
 void (*sa_handler) (int);
 unsigned long sa_flags;
 void (*sa_restorer) (void);
 unsigned sa_mask[2];
};
struct stat_t {
  uint64_t st_dev;
  uint64_t st_ino;
  uint32_t st_mode;
  uint32_t st_nlink;
  uint32_t st_uid;
  uint32_t st_gid;
  uint64_t st_rdev;
  uint64_t __pad1;
  int64_t st_size;
  int32_t st_blksize;
  int32_t __pad2;
  int64_t st_blocks;
  int64_t st_atime;
  uint64_t st_atime_nsec;
  int64_t st_mtime;
  uint64_t st_mtime_nsec;
  int64_t st_ctime;
  uint64_t st_ctime_nsec;
  uint32_t __unused4;
  uint32_t __unused5;
};
typedef sigaction_t* sigaction_p;
typedef uint64_t sigset_t;
typedef sigset_t *sigset_p;
struct iovec;
typedef iovec* iovec_p;
struct timeval;
typedef timeval timeval_t;
typedef timeval_t* timeval_p;
struct sockaddr;
typedef sockaddr* sockaddr_p;
struct shmid_ds;
typedef shmid_ds* shmid_ds_p;
struct itimerval;
typedef itimerval* itimerval_p;
struct msghdr;
typedef msghdr* msghdr_p;
struct rusage;
typedef rusage* rusage_p;
struct utsname;
struct utsname
{
  char sysname[65];
  char nodename[65];
  char release[65];
  char version[65];
  char machine[65];
  char domainname[65];
};
typedef utsname* utsname_p;
struct sembuf;
typedef sembuf* sembuf_p;
struct msgbuf;
typedef msgbuf* msgbuf_p;

struct msqid_ds;
typedef msqid_ds* msqid_ds_p;
typedef int qid_t;
struct linux_dirent;
typedef linux_dirent* linux_dirent_p;
struct linux_dirent64;
typedef linux_dirent64* linux_dirent64_p;
struct sigevent;
typedef sigevent* sigevent_p;
typedef void *timer_t;
typedef timer_t* timer_p;
struct timezone;
typedef timezone* timezone_p;
struct rlimit;
typedef rlimit* rlimit_p;
struct rlimit64;
struct file_handle;
typedef file_handle* file_handle_p;
typedef rlimit64* rlimit64_p;
struct sysinfo;
struct cap_user_header;
struct siginfo_t;
typedef siginfo_t* siginfo_p;
struct stack_t;
typedef stack_t* stack_p;
struct utimbuf;
typedef utimbuf* utimbuf_p;
struct cap_user_data;
struct ustat;
typedef ustat* ustat_p;
struct statfs_t;
struct bpf_attr;
typedef bpf_attr* bpf_attr_p;
struct sched_attr;
typedef sched_attr* sched_attr_p;
struct sched_param;
typedef sched_param* sched_param_p;
struct sysctl_args;
typedef sysctl_args* sysctl_args_p;
struct task_struct;
typedef task_struct* task_struct_p;
struct timex;
typedef timex* timex_p;
struct vptr_t;
struct pt_regs;
typedef pt_regs* pt_regs_p;
struct aio_context_t;
typedef aio_context_t* aio_context_p;
struct io_event;
typedef io_event* io_event_p;
struct iocb;
struct itimerspec;
typedef itimerspec* itimerspec_p;
struct epoll_event;
typedef epoll_event* epoll_event_p;
struct mq_attr;
typedef mq_attr* mq_attr_p;
struct stat_t;
struct pollfd;
typedef pollfd* pollfd_p;
typedef stat_t * stat_p;
typedef iocb* iocb_p;
typedef cap_user_header* cap_user_header_t;
typedef int mqd_t;
typedef cap_user_data* cap_user_data_t;
typedef sysinfo* sysinfo_p;
typedef statfs_t* statfs_p;
typedef int key_t;
typedef key_t* key_p;
typedef int sig_t;
typedef sig_t* sig_p;
typedef int uid_t;
typedef uid_t* uid_p;
typedef int gid_t;
typedef gid_t* gid_p;
typedef int umode_t;
struct kexec_segment;
typedef kexec_segment* kexec_segment_p;
struct robust_list_head;
typedef robust_list_head* robust_list_head_p;



typedef int32_t key_t;
typedef int32_t pid_t;






typedef int64_t intptr_t;
typedef uint64_t uintptr_t;
typedef int64_t off64_t;
struct fd_t : protected wrap_t<uint32_t>
{
  fd_t()
    :wrap_t(-1)
  {
  };
  using wrap_t::wrap_t;
  using wrap_t::operator val_t&;
  using wrap_t::operator val_t;
};

typedef fd_t* fd_p;
struct pollfd_t {
  fd_t fd;
  short events;
  short revents;
};
typedef int64_t clock_t;
typedef int64_t off_t;
typedef off_t* off_p;
struct perf_event_attr;
typedef perf_event_attr* perf_event_attr_p;
typedef int64_t suseconds_t;
typedef int64_t syscall_slong_t;
typedef int32_t clockid_t;
typedef int64_t time_t;
typedef time_t* time_p;
namespace std {
typedef int64_t ptrdiff_t;
};
using std::ptrdiff_t;
typedef uint32_t mode_t;
typedef uint64_t* size_p;
namespace std {
typedef uint64_t size_t;
typedef int64_t ssize_t;
}
using std::ssize_t;
using std::size_t;
typedef uint64_t ino64_t;
struct timeval
{
  time_t tv_sec;
  int64_t tv_usec;
  char *format(char *buf, char *end) const;
};
struct timespec
{
  time_t tv_sec;
  int64_t tv_nsec;
  char *format(char *buf, char *end) const;
};
typedef timespec timespec_t;
enum ftype_t {
 DT_UNKNOWN = 0,
 DT_FIFO = 1,
 DT_CHR = 2,
 DT_DIR = 4,
 DT_BLK = 6,
 DT_REG = 8,
 DT_LNK = 10,
 DT_SOCK = 12,
 DT_WHT = 14
};
struct linux_dirent {
 ino64_t d_ino;
 off64_t d_off;
 unsigned short d_reclen;
 unsigned char d_type;
 char d_name[];

 linux_dirent *next() {
  return (linux_dirent*)(((char*)this)+this->d_reclen);
 };
};
namespace fmt {
  struct fmt_t;
};
struct iovec {
 void *iov_base;
 size_t iov_len;
  iovec()
    : iov_base(0), iov_len(0)
  {
  };
  iovec(void *iov_base, size_t iov_len=-1)
    : iov_base((void*)iov_base), iov_len(iov_len)
  {
    if(iov_len>=0)
      return;
    const char *beg=(const char *)iov_base;
    const char *end=beg;
    while(*end)
      ++end;
    iov_len=end-beg;
  };
  iovec(const char *iov_base, const char *iov_end)
    : iov_base((void*)iov_base), iov_len(iov_end-iov_base)
  {
  };
  iovec(const char *iov_base, size_t iov_len)
    : iov_base((void*)iov_base), iov_len(iov_len)
  {
  };
  iovec(char *iov_base, size_t iov_len)
    : iov_base((void*)iov_base), iov_len(iov_len)
  {
  };
};

typedef timespec* timespec_p;


// # define NULL nullptr


// # define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)



// #  1 "inc/c_str.hh" 1
       

// #  1 "inc/template-glue.hh" 1
// #  1 "inc/types.hh" 1
// #  2 "inc/template-glue.hh" 2

       

namespace std {
  template<typename _type>
    struct remove_reference {
      typedef _type type;
    };
  template<typename _type>
    struct remove_reference<_type&> {
      typedef _type type;
    };
  template<typename _type>
    struct remove_reference<_type&&> {
      typedef _type type;
    };

  template< class T >
    using remove_reference_t = typename remove_reference<T>::type;

  template< class T >
    constexpr T&& forward( std::remove_reference_t<T>& t ) noexcept
    {
      return (T&&)t;
    };
  template< class T >
    constexpr T&& forward( std::remove_reference_t<T>&& t ) noexcept
    {
      return t;
    };

  template <typename T>
    constexpr typename remove_reference<T>::type&& move(T&& t) noexcept {
      return static_cast<typename remove_reference<T>::type&&>(t);
    }


  template <typename>
    struct function_traits;






  template <typename T>
    constexpr auto min(T&& a) {
      return a;
    };
  template <typename C, typename D>
    constexpr auto min(C&& a, D&& b) {
      return a<b?a:b;
    };
  template <typename T, typename... Ts>
    requires (requires (T&& a, Ts&&... args) { (... , (args < a)); })
    constexpr auto min(T&& a, Ts&&... args) -> decltype(auto) {
      return min(std::forward<T>(a), min(std::forward<Ts>(args)...));
    }


  template <typename T>
    struct remove_cv { using type = T; };
  template <typename T>
    struct remove_cv<const T> { using type = T; };
  template <typename T>
    struct remove_cv<volatile T> { using type = T; };
  template <typename T>
    struct remove_cv<const volatile T> { using type = T; };


  template <typename T>
    using decay_t = typename remove_cv<typename remove_reference<T>::type>::type;

  template <typename... Ts>
    struct tuple;


  template<>
    struct tuple<> {};


  template <typename Head, typename... Tail>
    struct tuple<Head, Tail...> : tuple<Tail...> {
      Head head;

      tuple() = default;

      template <typename H, typename... T>
        tuple(H&& h, T&&... t)
        : tuple<Tail...>(std::forward<T>(t)...), head(std::forward<H>(h))
        {
        }
    };

  template <typename... Ts>
    constexpr auto make_tuple(Ts&&... args) {
      return tuple<std::decay_t<Ts>...>(std::forward<Ts>(args)...);
    }
  template <typename T>
    struct tuple_size;

  template <typename... Ts>
    struct tuple_size<tuple<Ts...>> {
      static constexpr size_t value = sizeof...(Ts);
    };



  template <size_t I, typename Tuple>
    struct tuple_element_helper;


  template <size_t I, typename Head, typename... Tail>
    struct tuple_element_helper<I, tuple<Head, Tail...>> {
      using type = typename tuple_element_helper<I - 1, tuple<Tail...>>::type;

      static type& get(tuple<Head, Tail...>& t) {
        return tuple_element_helper<I - 1, tuple<Tail...>>::get(t);
      }

      static const type& get(const tuple<Head, Tail...>& t) {
        return tuple_element_helper<I - 1, tuple<Tail...>>::get(t);
      }
    };


  template <typename Head, typename... Tail>
    struct tuple_element_helper<0, tuple<Head, Tail...>> {
      using type = Head;

      static type& get(tuple<Head, Tail...>& t) {
        return t.head;
      }

      static const type& get(const tuple<Head, Tail...>& t) {
        return t.head;
      }
    };


  template <size_t I, typename Tuple>
    auto& get(Tuple& t) {
      return tuple_element_helper<I, Tuple>::get(t);
    }

  template <size_t I, typename Tuple>
    const auto& get(const Tuple& t) {
      return tuple_element_helper<I, Tuple>::get(t);
    }
  template <size_t... Is>
    struct index_sequence {};

  template <size_t N, size_t... Is>
    struct make_index_sequence_impl : make_index_sequence_impl<N - 1, N - 1, Is...> {};

  template <size_t... Is>
    struct make_index_sequence_impl<0, Is...> {
      using type = index_sequence<Is...>;
    };

  template <size_t N>
    using make_index_sequence = typename make_index_sequence_impl<N>::type;




  template <typename Tuple, typename Func, size_t... Is>
    void tuple_for_each_impl(Tuple&& tup, Func&& func, index_sequence<Is...>) {
      (func(std::get<Is>(tup)), ...);
    }

  template <typename Tuple, typename Func>
    void tuple_for_each(Tuple&& tup, Func&& func) {
      constexpr size_t N = std::tuple_size<std::remove_reference_t<Tuple>>::value;
      tuple_for_each_impl(
          std::forward<Tuple>(tup),
          std::forward<Func>(func),
          make_index_sequence<N>{}
          );
    }


  template <typename T1, typename T2>
    struct is_same {
      static constexpr bool value = false;
    };

  template <typename T>
    struct is_same<T, T> {
      static constexpr bool value = true;
    };


  template <typename T1, typename T2>
    inline constexpr bool is_same_v = is_same<T1, T2>::value;
};
// #  4 "inc/c_str.hh" 2
// #  1 "inc/dbg.hh" 1
// # define NDEBUG 

namespace dbg {
  struct runtime_error
  {
    struct body_t {
      const char *what;
    } body;
    runtime_error(const char *what)
      : body{what}
    {
    };
  };
  template<typename ...arg_t>
    void __xthrow(arg_t ... args);
  void __xassert(const char *cond);
};

// # define nop() 
// # define macwrap(x,y) do{ x; y; }while(0)
// # define xsrcpos() __FILE__ , ":" , __LINE__ , ":  "
// # define xtrace2(x,y) macwrap( log(xscrpos(),x,"\n");
// # define xtrace(x) xtrace2(x,nop())
// # define xcomment(x) xtrace2(x,nop())
// # define xexpose(x) xtrace2( #x , " => " , x, nop() )
// # define xcarp(x) xtrace2( "warning:             " , x, nop() )
// # define xcroak(x) xtrace2( "error:               " , x, abort() )
// # define xconfess(x) xtrace2( "confess:             " x, dump(true) )
// # define xcluck(x) xtrace2( "cluck:               " x, dump(false) )
// # define xcheckin() xtrace2( __PRETTY_FUNCTION__, nop() )
// # define xassert(x) if(!(x)) { dbg::__xassert( #x ); }
// # define xnv(x) #x " => " (x)
// # define dbg() __FILE__ ":" __LINE__ ":"
// # define xthrow(x,y) do{ dbg::__xthrow(x,y); }while(false)

// # define xthrowre(y) xthrow(runtime_error,y)
// #  5 "inc/c_str.hh" 2
// #  1 "inc/itr_ops.hh" 1
       


namespace str {
  struct c_str;
};
namespace itr {
  using std::min;
 template<class dst_t, class val_t>
  inline dst_t fill(dst_t beg, dst_t end, val_t val){
    while(beg!=end)
      *beg++=val;
    return beg;
  };
  template<class dst_t, class src_t>
  inline dst_t rcopy_n(dst_t db, src_t sb,size_t N){
    size_t n(N);
    db+=n;
    *db=0;
    sb+=n;
    while(n--)
      *--db=*--sb;
    return db+N;
  };
  template<class dst_t, class src_t>
  inline dst_t fcopy_n(dst_t db, src_t sb,size_t n){
    while(n--)
      *db++=*sb++;
    return db;
  };
  void fuck_off(int res, const char *msg);
  template<class dst_t, class src_t>
  inline dst_t copy_n(dst_t db, src_t sb, size_t n){
    dst_t res;
    if(n>=0 && n<=4096) {
      if(&*db<&*sb)
        res= fcopy_n(db,sb,n);
      else
        res= rcopy_n(db,sb,n);
    } else {
      fuck_off(2,"fuck!\n");
    };
    return res;
  };
  template<class dst_t, class src_t>
  inline dst_t copy(dst_t db, dst_t de, src_t sb, src_t se)
  {
    return copy_n(db,sb,min(se-sb,de-db));
  };
  inline char *copy(char *db, char *de, void *sb, size_t sl)
  {
    return copy(db,de,(char*)sb,((char*)sb)+sl);
  };
  inline char *copy(char *db, char *de, str::c_str str);
  inline char *copy(char *db, char *de, iovec vec) {
    return copy(db,de,vec.iov_base,vec.iov_len);
  };
  template<class itr_t, class val_t>
    inline auto find_val(itr_t db, itr_t de, val_t val){
      while(db!=de)
        if(*db==val)
          break;
        else
          db++;
      return db;
    };
  template<class itr_t, class pred_t>
    inline auto find_pred(itr_t db, itr_t de, pred_t pred)
    {
      while(db!=de) {
        if(pred(*db))
          break;
      };
      return db;
    }
  inline size_t len(const char *beg, const char *end=0){
    size_t max=end?end-beg:size_t(-1);
    size_t i;
    for(i=0;beg[i];i++)
      ;
    return i;
  };
  inline int str_cmp(const char *lhs, const char *rhs)
  {
    while(*lhs && *rhs){
      if(*lhs!=*rhs)
        return (lhs>rhs?-1:1);
    };
    if(*lhs)
      return -1;
    if(*rhs)
      return 1;
    return 0;
  };
};
// #  6 "inc/c_str.hh" 2
namespace str {
  class c_str {
    struct body_t {
      char *beg;
      char *end;
      body_t(char *beg, char*xend)
        :beg(beg),end(xend)
      {
        if(end)
          return;
        if(!beg)
          return;
        end=beg;
        while(*end)
          end++;
      };
      body_t(char *beg, size_t len)
        : beg(beg),end(beg+len)
      {
      };
    } body;
    static const char null_str[1];
    static const char colon[2];
    static const char newline[2];
    public:
    c_str(char *b, char *e = 0)
      :body(b,e)
    {
      if(!body.beg)
        body.end=0;
      if(!body.end)
        body.end=body.beg+itr::len(body.beg);
    };
    c_str(const char *b=0, const char *e=0)
      : body((char*)b,(char*)(e))
    {
    };
    c_str(const char *b, size_t l)
      : body((char*)b,(char*)(b+l))
    {
    };
    c_str(char *b, size_t l)
      : body(b,b+l)
    {
    };
    template<size_t n>
      c_str(char(b)[n], bool i)
      :body(b,b+n-(b[n-1]?0:1))
      {
      }
    c_str(const iovec &vec)
      : body((char*)vec.iov_base, vec.iov_len)
    {
    };
    c_str(const c_str &lhs)
      : body(lhs.body.beg,lhs.body.end)
    {
    };
    operator iovec() const {
      return iovec{ (void*)beg(), size() };
    };
    size_t len() const
    {
      return body.end-body.beg;
    };
    size_t size() const {
      return body.end-body.beg;
    };
    char operator[](size_t pos) const
    {
      return body.beg[pos];
    };
    operator bool() const
    {
      return body.beg<body.end;
    }
    c_str operator++(int)
    {
      c_str res(*this);
      if(body.beg<body.end)
        ++body.beg;
      return res;
    };
    c_str &operator++()
    {
      if(body.beg<body.end)
        ++body.beg;
      return *this;
    };
    char operator*() const {
      return *body.beg;
    };
    const char *beg() const {
      return body.beg;
    };
    char *beg() {
      return body.beg;
    };
    const char *begin() const {
      return body.beg;
    };
    char *begin() {
      return body.beg;
    };
    const char *end() const {
      return body.end;
    };
    char *end() {
      return body.end;
    };
    friend bool lt(const c_str &lhs, const c_str &rhs) {
      auto msize=std::min(lhs.size(),rhs.size());
      for(auto i=0*msize;i<msize;i++){
        if(lhs[i]!=rhs[i])
          return lhs[i]<rhs[i]?true:false;
      };
      return lhs.size()<rhs.size();
    };
  };
}
namespace itr {
  using str::c_str;
  inline char *copy(char *db, char *de, c_str str) {
    if(db+str.len()>=de)
      return 0;
    for(int i=0;i<str.len();i++)
      *db++=str[i];
    return db;
  };
  char *copy(char *db, char *de, iovec vec);
};
// #  326 "inc/types.hh" 2
// #  4 "inc/errno.hh" 2
// #  1 "inc/errno_enum.hh" 1

// # define ERR_LIST(X) X( EPERM, 1, "Operation_not_permitted" ) X( ENOENT, 2, "No_such_file_or_directory" ) X( ESRCH, 3, "No_such_process" ) X( EINTR, 4, "Interrupted_system_call" ) X( EIO, 5, "I/O_error" ) X( ENXIO, 6, "No_such_device_or_address" ) X( E2BIG, 7, "Argument_list_too_long" ) X( ENOEXEC, 8, "Exec_format_error" ) X( EBADF, 9, "Bad_file_number" ) X( ECHILD, 10, "No_child_processes" ) X( EAGAIN, 11, "Try_again" ) X( ENOMEM, 12, "Out_of_memory" ) X( EACCES, 13, "Permission_denied" ) X( EFAULT, 14, "Bad_address" ) X( ENOTBLK, 15, "Block_device_required" ) X( EBUSY, 16, "Device_or_resource_busy" ) X( EEXIST, 17, "File_exists" ) X( EXDEV, 18, "Cross-device_link" ) X( ENODEV, 19, "No_such_device" ) X( ENOTDIR, 20, "Not_a_directory" ) X( EISDIR, 21, "Is_a_directory" ) X( EINVAL, 22, "Invalid_argument" ) X( ENFILE, 23, "File_table_overflow" ) X( EMFILE, 24, "Too_many_open_files" ) X( ENOTTY, 25, "Not_a_typewriter" ) X( ETXTBSY, 26, "Text_file_busy" ) X( EFBIG, 27, "File_too_large" ) X( ENOSPC, 28, "No_space_left_on_device" ) X( ESPIPE, 29, "Illegal_seek" ) X( EROFS, 30, "Read-only_file_system" ) X( EMLINK, 31, "Too_many_links" ) X( EPIPE, 32, "Broken_pipe" ) X( EDOM, 33, "Math_argument_out_of_domain_of_func" ) X( ERANGE, 34, "Math_result_not_representable" )
// #  37 "inc/errno_enum.hh"
// # define X(s,n,m) s = n,

namespace sys {
  enum errno_t : int32_t {
    EPERM = 1, ENOENT = 2, ESRCH = 3, EINTR = 4, EIO = 5, ENXIO = 6, E2BIG = 7, ENOEXEC = 8, EBADF = 9, ECHILD = 10, EAGAIN = 11, ENOMEM = 12, EACCES = 13, EFAULT = 14, ENOTBLK = 15, EBUSY = 16, EEXIST = 17, EXDEV = 18, ENODEV = 19, ENOTDIR = 20, EISDIR = 21, EINVAL = 22, ENFILE = 23, EMFILE = 24, ENOTTY = 25, ETXTBSY = 26, EFBIG = 27, ENOSPC = 28, ESPIPE = 29, EROFS = 30, EMLINK = 31, EPIPE = 32, EDOM = 33, ERANGE = 34,
    EWOULDBLOCK=EAGAIN
  };
};

// # undef X
// # undef ERR_LIST
// #  5 "inc/errno.hh" 2
// #  1 "inc/attrs.hh" 1







// # define AIL __attribute__((__always_inline__))
// # define NOR __attribute__((__noreturn__))
// #  6 "inc/errno.hh" 2

namespace str {
  struct c_str;
};
namespace sys {
  using str::c_str;


  extern errno_t errno;
  const c_str strerror(errno_t err=errno);
  void perror(const char *msg1, const char *msg2);
  void perror(const char *msg1);


  void die(int res, const char *m1) __attribute__((__noreturn__));
  void die(int res, const char *msg1, const char *msg2)__attribute__((__noreturn__));
  void die(const char *msg1, const char *msg2)__attribute__((__noreturn__));
  void die(const char *msg1);
  void pexit(int res, const char *msg1) __attribute__((__noreturn__));
  void pexit(int res, const char *msg1, const char *msg2) __attribute__((__noreturn__));

  void pexit(int res, const char *msg1, const char *msg2);
  void pexit(int res, const char *msg1);
  void die(int res, const char * msg1);
  void die(int res, const char * msg1, const char * msg2);
  void die(int res, const c_str &msg1);
  void die(int res, const c_str &msg1, const c_str &msg2);
  inline void die(const c_str &msg1) {
    die(99,msg1);
  };
  inline void die(const c_str &msg1, const c_str &msg2) {
    die(99,msg1,msg2);
  };
};
// #  4 "inc/syscall.hh" 2
// #  1 "inc/types.hh" 1
// #  5 "inc/syscall.hh" 2


namespace sys
{
// # define linux_dirent64 linux_dirent
  enum open_mode
  {
    o_default= 0664

  };

  enum open_flags
  {
    o_rdonly = 0000,
    o_wronly = 0001,
    o_rdwr = 0002,
    o_mask = 0003,
    o_creat = 00000100,
    o_excl = 00000200,
    o_noctty = 00000400,
    o_trunc = 00001000,
    o_append = 00002000,
    o_nonblock = 00004000,
    o_dsync = 00010000,
    o_fasync = 00020000,
    o_direct = 00040000,
    o_largefile= 00100000,
    o_directory= 00200000,
    o_nofollow = 00400000,
    o_noatime = 01000000,
    o_cloexec = 02000000,
  };
  inline open_flags operator|(open_flags lhs, open_flags rhs)
  {
    return open_flags(int(lhs) | int(rhs));
  }
  inline open_flags operator&(open_flags lhs, open_flags rhs)
  {
    return open_flags(int(lhs) & int(rhs));
  }
  void err_log(errno_t err);
  void err_ignore(errno_t err);
  void err_retry_on_trans_error(errno_t err);
  void err_fatal(errno_t err);

  typedef void (*errhand_t)(errno_t);
  void set_errno(errno_t val, errhand_t hand=err_log);
  inline void set_errno(int32_t val, errhand_t hand=err_log){
    set_errno((errno_t)val,hand);
  };
  template<class res_t>
    res_t chk_return(uint64_t val, errhand_t hand=err_log)
    {
      if(val>uint64_t(-4096))
        set_errno(int64_t(val),hand);
      return res_t(val);
    };
  constexpr auto UTIME_NOW = (((1<<30)-1));
  constexpr auto UTIME_OMIT = (((1<<30)-2));
  constexpr auto AT_FDCWD=-100;

  enum origin_t
  {
    set= 0,
    cur= 1,
    end= 2
  };
  enum mmap_prot_t
  {

    prot_none = 0x0,
    prot_read = 0x1,
    prot_write= 0x2,
    prot_exec = 0x4,
  };
  enum mmap_flag_t
  {
    map_private = 0x02,
    map_shared = 0x01,
    map_fixed = 0x10,
    map_anon = 0x20,
    map_anonymous= map_anon,
    map_growsdown= 0x00100,
    map_noreserve= 0x04000,
    map_nonblock = 0x10000,
    map_populate = 0x08000,
    map_stack = 0x20000,
  };
}





// #  1 "inc/syscall.gen.hh" 1

       

namespace sys {



ssize_t read(fd_t fd, ostr_t buf, size_t count, errhand_t hand = err_log)
  ;





ssize_t write(fd_t fd, istr_t buf, size_t count, errhand_t hand = err_log)
  ;





fd_t open(istr_t path, int flags, int mode, errhand_t hand = err_log)
  ;





int close(fd_t fd, errhand_t hand = err_log)
  ;





int stat(istr_t path, stat_p statbuf, errhand_t hand = err_log)
  ;





int fstat(fd_t fd, stat_p statbuf, errhand_t hand = err_log)
  ;





int lstat(istr_t path, stat_p statbuf, errhand_t hand = err_log)
  ;





int poll(pollfd_p ufds, unsigned nfds, long timeout_msecs, errhand_t hand = err_log)
  ;





int lseek(fd_t fd, off_t offset, unsigned origin, errhand_t hand = err_log)
  ;





char* mmap(void* addr, size_t len, int prot, int flags, fd_t fd, off_t off, errhand_t hand = err_log)
  ;





int mprotect(uint64_t start, size_t len, uint64_t prot, errhand_t hand = err_log)
  ;





int munmap(uint64_t addr, size_t len, errhand_t hand = err_log)
  ;





int brk(void_p brk, errhand_t hand = err_log)
  ;





int rt_sigaction(int sig, sigaction_p act, sigaction_p oact, size_t sigsetsize, errhand_t hand = err_log)
  ;





int rt_sigprocmask(int how, sigset_p nset, sigset_p oset, size_t sigsetsize, errhand_t hand = err_log)
  ;





int rt_sigreturn(uint64_t __unused, errhand_t hand = err_log)
  ;





int ioctl(fd_t fd, unsigned cmd, uint64_t arg, errhand_t hand = err_log)
  ;





int pread64(fd_t fd, ostr_t buf, size_t count, off_t pos, errhand_t hand = err_log)
  ;





int pwrite64(fd_t fd, istr_t buf, size_t count, off_t pos, errhand_t hand = err_log)
  ;





int readv(fd_t fd, iovec_p vec, uint64_t vlen, errhand_t hand = err_log)
  ;





int writev(fd_t fd, iovec_p vec, uint64_t vlen, errhand_t hand = err_log)
  ;





int access(istr_t path, int mode, errhand_t hand = err_log)
  ;





int pipe(fd_p filedes, errhand_t hand = err_log)
  ;





int select(int n, fdset_p inp, fdset_p outp, fdset_p exp, timeval_p tvp, errhand_t hand = err_log)
  ;





int sched_yield(errhand_t hand = err_log)
  ;





int mremap(uint64_t addr, uint64_t old_len, uint64_t new_len, uint64_t flags, uint64_t new_addr, errhand_t hand = err_log)
  ;





int msync(uint64_t start, size_t len, int flags, errhand_t hand = err_log)
  ;





int mincore(uint64_t start, size_t len, ostr_t vec, errhand_t hand = err_log)
  ;





int madvise(uint64_t start, size_t len_in, int behavior, errhand_t hand = err_log)
  ;





int shmget(key_t key, size_t size, int shmflg, errhand_t hand = err_log)
  ;





int shmat(int shmid, ostr_t shmaddr, int shmflg, errhand_t hand = err_log)
  ;





int shmctl(int shmid, int cmd, shmid_ds_p buf, errhand_t hand = err_log)
  ;





int dup(unsigned fildes, errhand_t hand = err_log)
  ;





int dup2(fd_t oldfd, fd_t newfd, errhand_t hand = err_log)
  ;





int pause(errhand_t hand = err_log)
  ;





int nanosleep(timespec_p rqtp, timespec_p rmtp, errhand_t hand = err_log)
  ;





int getitimer(int which, itimerval_p value, errhand_t hand = err_log)
  ;





int alarm(unsigned seconds, errhand_t hand = err_log)
  ;





int setitimer(int which, itimerval_p value, itimerval_p ovalue, errhand_t hand = err_log)
  ;





int getpid(errhand_t hand = err_log)
  ;





int sendfile(int out_fd, int in_fd, off_p offset, size_t count, errhand_t hand = err_log)
  ;





int socket(int family, int type, int protocol, errhand_t hand = err_log)
  ;





int connect(fd_t fd, sockaddr_p uservaddr, int addrlen, errhand_t hand = err_log)
  ;





int accept(fd_t fd, sockaddr_p upeer_sockaddr, int32_p upeer_addrlen, errhand_t hand = err_log)
  ;





int sendto(fd_t fd, void_p buff, size_t len, unsigned flags, sockaddr_p addr, int addr_len, errhand_t hand = err_log)
  ;





int recvfrom(fd_t fd, void_p ubuf, size_t size, unsigned flags, sockaddr_p addr, int32_p addr_len, errhand_t hand = err_log)
  ;





int sendmsg(fd_t fd, msghdr_p msg, unsigned flags, errhand_t hand = err_log)
  ;





int recvmsg(fd_t fd, msghdr_p msg, unsigned flags, errhand_t hand = err_log)
  ;





int shutdown(fd_t fd, int how, errhand_t hand = err_log)
  ;





int bind(fd_t fd, sockaddr_p umyaddr, int addrlen, errhand_t hand = err_log)
  ;





int listen(fd_t fd, int backlog, errhand_t hand = err_log)
  ;





int getsockname(fd_t fd, sockaddr_p usockaddr, int32_p usockaddr_len, errhand_t hand = err_log)
  ;





int getpeername(fd_t fd, sockaddr_p usockaddr, int32_p usockaddr_len, errhand_t hand = err_log)
  ;





int socketpair(int family, int type, int protocol, int32_p usockvec, errhand_t hand = err_log)
  ;





int setsockopt(fd_t fd, int level, int optname, ostr_t optval, int optlen, errhand_t hand = err_log)
  ;





int getsockopt(fd_t fd, int level, int optname, ostr_t optval, int32_p optlen, errhand_t hand = err_log)
  ;





int clone(uint64_t clone_flags, uint64_t newsp, void_p parent_tid, void_p child_tid, errhand_t hand = err_log)
  ;





pid_t fork(errhand_t hand = err_log)
  ;





pid_t vfork(errhand_t hand = err_log)
  ;





int execve(const char * filename, char *const * argv, char *const * envp, errhand_t hand = err_log)
  __attribute__((__noreturn__));





void exit(int error_code, errhand_t hand = err_log)
  __attribute__((__noreturn__));





int wait4(pid_t upid, int32_p stat_addr, int options, rusage_p ru, errhand_t hand = err_log)
  ;





int kill(pid_t pid, int sig, errhand_t hand = err_log)
  ;





int uname(utsname_p name, errhand_t hand = err_log)
  ;





int shmdt(ostr_t shmaddr, errhand_t hand = err_log)
  ;





int msgget(key_t key, int msgflg, errhand_t hand = err_log)
  ;





int msgsnd(int msqid, msgbuf_p msgp, size_t msgsz, int msgflg, errhand_t hand = err_log)
  ;





int msgrcv(int msqid, msgbuf_p msgp, size_t msgsz, long msgtyp, int msgflg, errhand_t hand = err_log)
  ;





int msgctl(int msqid, int cmd, msqid_ds_p buf, errhand_t hand = err_log)
  ;





int fcntl(fd_t fd, unsigned cmd, uint64_t arg, errhand_t hand = err_log)
  ;





int flock(fd_t fd, unsigned cmd, errhand_t hand = err_log)
  ;





int fsync(fd_t fd, errhand_t hand = err_log)
  ;





int fdatasync(fd_t fd, errhand_t hand = err_log)
  ;





int truncate(istr_t path, long length, errhand_t hand = err_log)
  ;





int ftruncate(fd_t fd, uint64_t length, errhand_t hand = err_log)
  ;





ssize_t getdents(fd_t fd, linux_dirent_p dirent, size_t count, errhand_t hand = err_log)
  ;





int getcwd(ostr_t buf, uint64_t size, errhand_t hand = err_log)
  ;





int chdir(istr_t path, errhand_t hand = err_log)
  ;





int fchdir(fd_t fd, errhand_t hand = err_log)
  ;





int rename(istr_t opath, istr_t npath, errhand_t hand = err_log)
  ;





int mkdir(istr_t path, int mode, errhand_t hand = err_log)
  ;





int rmdir(istr_t path, errhand_t hand = err_log)
  ;





int creat(istr_t path, int mode, errhand_t hand = err_log)
  ;





int link(istr_t opath, istr_t npath, errhand_t hand = err_log)
  ;





int unlink(istr_t path, errhand_t hand = err_log)
  ;





int symlink(istr_t opath, istr_t npath, errhand_t hand = err_log)
  ;





int readlink(istr_t path, ostr_t buf, int bufsiz, errhand_t hand = err_log)
  ;





int chmod(istr_t path, mode_t mode, errhand_t hand = err_log)
  ;





int fchmod(fd_t fd, mode_t mode, errhand_t hand = err_log)
  ;





int chown(istr_t path, uid_t user, gid_t group, errhand_t hand = err_log)
  ;





int fchown(fd_t fd, uid_t user, gid_t group, errhand_t hand = err_log)
  ;





int lchown(istr_t path, uid_t user, gid_t group, errhand_t hand = err_log)
  ;





int umask(int mask, errhand_t hand = err_log)
  ;





int gettimeofday(timeval_p tv, timezone_p tz, errhand_t hand = err_log)
  ;





int getrlimit(unsigned resource, rlimit_p rlim, errhand_t hand = err_log)
  ;





int getrusage(int who, rusage_p ru, errhand_t hand = err_log)
  ;





int sysinfo(sysinfo_p info, errhand_t hand = err_log)
  ;





int times(sysinfo_p info, errhand_t hand = err_log)
  ;





int ptrace(long request, long pid, uint64_t addr, uint64_t data, errhand_t hand = err_log)
  ;





int getuid(errhand_t hand = err_log)
  ;





int syslog(int type, ostr_t buf, int len, errhand_t hand = err_log)
  ;





int getgid(errhand_t hand = err_log)
  ;





int setuid(uid_t uid, errhand_t hand = err_log)
  ;





int setgid(gid_t gid, errhand_t hand = err_log)
  ;





int geteuid(errhand_t hand = err_log)
  ;





int getegid(errhand_t hand = err_log)
  ;





int setpgid(pid_t pid, pid_t pgid, errhand_t hand = err_log)
  ;





int getppid(errhand_t hand = err_log)
  ;





int getpgrp(errhand_t hand = err_log)
  ;





int setsid(errhand_t hand = err_log)
  ;





int setreuid(uid_t ruid, uid_t euid, errhand_t hand = err_log)
  ;





int setregid(gid_t rgid, gid_t egid, errhand_t hand = err_log)
  ;





int getgroups(int gidsetsize, gid_p grouplist, errhand_t hand = err_log)
  ;





int setgroups(int gidsetsize, gid_p grouplist, errhand_t hand = err_log)
  ;





int setresuid(uid_p ruid, uid_p euid, uid_p suid, errhand_t hand = err_log)
  ;





int getresuid(uid_p ruid, uid_p euid, uid_p suid, errhand_t hand = err_log)
  ;





int setresgid(gid_t rgid, gid_t egid, gid_t sgid, errhand_t hand = err_log)
  ;





int getresgid(gid_p rgid, gid_p egid, gid_p sgid, errhand_t hand = err_log)
  ;





int getpgid(pid_t pid, errhand_t hand = err_log)
  ;





int setfsuid(uid_t uid, errhand_t hand = err_log)
  ;





int setfsgid(gid_t gid, errhand_t hand = err_log)
  ;





int getsid(pid_t pid, errhand_t hand = err_log)
  ;





int capget(cap_user_header_t header, cap_user_data_t dataptr, errhand_t hand = err_log)
  ;





int capset(cap_user_header_t header, const cap_user_data_t data, errhand_t hand = err_log)
  ;





int rt_sigpending(sigset_p set, size_t sigsetsize, errhand_t hand = err_log)
  ;





int rt_sigtimedwait(const sigset_p uthese, siginfo_p uinfo, timespec_p uts, size_t sigsetsize, errhand_t hand = err_log)
  ;





int rt_sigqueueinfo(pid_t pid, int sig, siginfo_p uinfo, errhand_t hand = err_log)
  ;





int rt_sigsuspend(sigset_p unewset, size_t sigsetsize, errhand_t hand = err_log)
  ;





int sigaltstack(const stack_p uss, stack_p uoss, errhand_t hand = err_log)
  ;





int utime(ostr_t path, utimbuf_p times, errhand_t hand = err_log)
  ;





int mknod(istr_t path, umode_t mode, unsigned dev, errhand_t hand = err_log)
  ;





int personality(unsigned personality, errhand_t hand = err_log)
  ;





int ustat(unsigned dev, ustat_p ubuf, errhand_t hand = err_log)
  ;





int statfs(istr_t path, statfs_p buf, errhand_t hand = err_log)
  ;





int fstatfs(fd_t fd, statfs_p buf, errhand_t hand = err_log)
  ;





int sysfs(int option, uint64_t arg1, uint64_t arg2, errhand_t hand = err_log)
  ;





int getpriority(int which, int who, errhand_t hand = err_log)
  ;





int setpriority(int which, int who, int niceval, errhand_t hand = err_log)
  ;





int sched_setparam(pid_t pid, const void * param, errhand_t hand = err_log)
  ;





int sched_getparam(pid_t pid, sched_param_p param, errhand_t hand = err_log)
  ;





int sched_setscheduler(pid_t pid, int policy, sched_param_p param, errhand_t hand = err_log)
  ;





int sched_getscheduler(pid_t pid, errhand_t hand = err_log)
  ;





int sched_get_priority_max(int policy, errhand_t hand = err_log)
  ;





int sched_get_priority_min(int policy, errhand_t hand = err_log)
  ;





int sched_rr_get_interval(pid_t pid, timespec_p interval, errhand_t hand = err_log)
  ;





int mlock(void_p start, size_t len, errhand_t hand = err_log)
  ;





int munlock(void_p start, size_t len, errhand_t hand = err_log)
  ;





int mlockall(int flags, errhand_t hand = err_log)
  ;





int munlockall(errhand_t hand = err_log)
  ;





int vhangup(errhand_t hand = err_log)
  ;





int modify_ldt(int func, void_p ptr, uint64_t bytecount, errhand_t hand = err_log)
  ;





int pivot_root(istr_t new_root, istr_t put_old, errhand_t hand = err_log)
  ;





int _sysctl(sysctl_args_p args, errhand_t hand = err_log)
  ;





int prctl(int option, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, errhand_t hand = err_log)
  ;





int arch_prctl(task_struct_p task, int code, uint64_t addr, errhand_t hand = err_log)
  ;





int adjtimex(timex_p txc_p, errhand_t hand = err_log)
  ;





int setrlimit(unsigned resource, rlimit_p rlim, errhand_t hand = err_log)
  ;





int chroot(istr_t path, errhand_t hand = err_log)
  ;





int sync(errhand_t hand = err_log)
  ;





int acct(istr_t name, errhand_t hand = err_log)
  ;





int settimeofday(timeval_p tv, timezone_p tz, errhand_t hand = err_log)
  ;





int mount(ostr_t dev_name, ostr_t dir_name, ostr_t type, uint64_t flags, void_p data, errhand_t hand = err_log)
  ;





int umount2(istr_t target, int flags, errhand_t hand = err_log)
  ;





int swapon(istr_t specialfile, int swap_flags, errhand_t hand = err_log)
  ;





int swapoff(istr_t specialfile, errhand_t hand = err_log)
  ;





int reboot(int magic1, int magic2, unsigned cmd, void_p arg, errhand_t hand = err_log)
  ;





int sethostname(ostr_t name, int len, errhand_t hand = err_log)
  ;





int setdomainname(ostr_t name, int len, errhand_t hand = err_log)
  ;





int iopl(unsigned level, pt_regs_p regs, errhand_t hand = err_log)
  ;





int ioperm(uint64_t from, uint64_t num, int turn_on, errhand_t hand = err_log)
  ;





int init_module(void_p umod, uint64_t len, istr_t uargs, errhand_t hand = err_log)
  ;





int delete_module(istr_t name_user, unsigned flags, errhand_t hand = err_log)
  ;





int quotactl(unsigned cmd, istr_t special, qid_t id, void_p addr, errhand_t hand = err_log)
  ;





int gettid(errhand_t hand = err_log)
  ;





int readahead(fd_t fd, off_t offset, size_t count, errhand_t hand = err_log)
  ;





int setxattr(istr_t path, istr_t name, const void_p value, size_t size, int flags, errhand_t hand = err_log)
  ;





int lsetxattr(istr_t path, istr_t name, const void_p value, size_t size, int flags, errhand_t hand = err_log)
  ;





int fsetxattr(fd_t fd, istr_t name, const void_p value, size_t size, int flags, errhand_t hand = err_log)
  ;





int getxattr(istr_t path, istr_t name, void_p value, size_t size, errhand_t hand = err_log)
  ;





int lgetxattr(istr_t path, istr_t name, void_p value, size_t size, errhand_t hand = err_log)
  ;





int fgetxattr(fd_t fd, istr_t name, void_p value, size_t size, errhand_t hand = err_log)
  ;





int listxattr(istr_t path, ostr_t list, size_t size, errhand_t hand = err_log)
  ;





int llistxattr(istr_t path, ostr_t list, size_t size, errhand_t hand = err_log)
  ;





int flistxattr(fd_t fd, ostr_t list, size_t size, errhand_t hand = err_log)
  ;





int removexattr(istr_t path, istr_t name, errhand_t hand = err_log)
  ;





int lremovexattr(istr_t path, istr_t name, errhand_t hand = err_log)
  ;





int fremovexattr(fd_t fd, istr_t name, errhand_t hand = err_log)
  ;





int tkill(pid_t pid, int sig, errhand_t hand = err_log)
  ;





time_t time(time_p tloc, errhand_t hand = err_log)
  ;





int futex(uint32_p uaddr, int op, uint32_t val, timespec_p utime, uint32_p uaddr2, uint32_t val3, errhand_t hand = err_log)
  ;





int sched_setaffinity(pid_t pid, size_t len, const void * user_mask_ptr, errhand_t hand = err_log)
  ;





int sched_getaffinity(pid_t pid, unsigned len, uint64_p user_mask_ptr, errhand_t hand = err_log)
  ;





int lookup_dcookie(uint64_t cookie64, long buf, long len, errhand_t hand = err_log)
  ;





int epoll_create(int size, errhand_t hand = err_log)
  ;





int remap_file_pages(uint64_t start, uint64_t size, uint64_t prot, uint64_t pgoff, uint64_t flags, errhand_t hand = err_log)
  ;





int getdents64(fd_t fd, linux_dirent64_p dirent, unsigned count, errhand_t hand = err_log)
  ;





int set_tid_address(int32_p tidptr, errhand_t hand = err_log)
  ;





int restart_syscall(errhand_t hand = err_log)
  ;





int semtimedop(int semid, sembuf_p tsops, unsigned nsops, timespec_p timeout, errhand_t hand = err_log)
  ;





int fadvise64(fd_t fd, off_t offset, size_t len, int advice, errhand_t hand = err_log)
  ;





int timer_create(const clockid_t which_clock, sigevent_p timer_event_spec, timer_p created_timer_id, errhand_t hand = err_log)
  ;





int timer_settime(timer_t timer_id, int flags, itimerspec_p new_setting, itimerspec_p old_setting, errhand_t hand = err_log)
  ;





int timer_gettime(timer_t timer_id, itimerspec_p setting, errhand_t hand = err_log)
  ;





int timer_getoverrun(timer_t timer_id, errhand_t hand = err_log)
  ;





int timer_delete(timer_t timer_id, errhand_t hand = err_log)
  ;





int clock_settime(const clockid_t which_clock, timespec_p tp, errhand_t hand = err_log)
  ;





int clock_gettime(const clockid_t which_clock, timespec_p tp, errhand_t hand = err_log)
  ;





int clock_getres(const clockid_t which_clock, timespec_p tp, errhand_t hand = err_log)
  ;





int clock_nanosleep(const clockid_t which_clock, int flags, timespec_p rqtp, timespec_p rmtp, errhand_t hand = err_log)
  ;





int exit_group(int error_code, errhand_t hand = err_log)
  __attribute__((__noreturn__));





int epoll_wait(int epfd, epoll_event_p events, int maxevents, int timeout, errhand_t hand = err_log)
  ;





int epoll_ctl(int epfd, int op, fd_t fd, epoll_event_p event, errhand_t hand = err_log)
  ;





int tgkill(pid_t tgid, pid_t pid, int sig, errhand_t hand = err_log)
  ;





int utimes(ostr_t path, timeval_p utimes, errhand_t hand = err_log)
  ;





int mbind(uint64_t start, uint64_t len, uint64_t mode, uint64_p nmask, uint64_t maxnode, unsigned flags, errhand_t hand = err_log)
  ;





int set_mempolicy(int mode, uint64_p nmask, uint64_t maxnode, errhand_t hand = err_log)
  ;





int get_mempolicy(int32_p policy, uint64_p nmask, uint64_t maxnode, uint64_t addr, uint64_t flags, errhand_t hand = err_log)
  ;





int mq_open(istr_t u_name, int oflag, mode_t mode, mq_attr_p u_attr, errhand_t hand = err_log)
  ;





int mq_unlink(istr_t u_name, errhand_t hand = err_log)
  ;





int mq_timedsend(mqd_t mqdes, istr_t u_msg_ptr, size_t msg_len, unsigned msg_prio, timespec_p u_abs_timeout, errhand_t hand = err_log)
  ;





int mq_timedreceive(mqd_t mqdes, ostr_t u_msg_ptr, size_t msg_len, uint32_p u_msg_prio, timespec_p u_abs_timeout, errhand_t hand = err_log)
  ;





int mq_notify(mqd_t mqdes, sigevent_p u_notification, errhand_t hand = err_log)
  ;





int mq_getsetattr(mqd_t mqdes, mq_attr_p u_mqstat, mq_attr_p u_omqstat, errhand_t hand = err_log)
  ;





int kexec_load(uint64_t entry, uint64_t nr_segments, kexec_segment_p segments, uint64_t flags, errhand_t hand = err_log)
  ;





int waitid(int which, pid_t upid, siginfo_p infop, int options, rusage_p ru, errhand_t hand = err_log)
  ;





int add_key(istr_t _type, istr_t _description, const void_p _payload, size_t plen, errhand_t hand = err_log)
  ;





int request_key(istr_t _type, istr_t _description, istr_t _callout_info, uint64_t destringid, errhand_t hand = err_log)
  ;





int keyctl(int option, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, errhand_t hand = err_log)
  ;





int ioprio_set(int which, int who, int ioprio, errhand_t hand = err_log)
  ;





int ioprio_get(int which, int who, errhand_t hand = err_log)
  ;





int inotify_init(errhand_t hand = err_log)
  ;





int inotify_add_watch(fd_t fd, istr_t path, uint32_t mask, errhand_t hand = err_log)
  ;





int inotify_rm_watch(fd_t fd, int32_t wd, errhand_t hand = err_log)
  ;





int migrate_pages(pid_t pid, uint64_t maxnode, uint64_p old_nodes, uint64_p new_nodes, errhand_t hand = err_log)
  ;





int openat(fd_t dfd, istr_t path, int flags, int mode, errhand_t hand = err_log)
  ;





int mkdirat(fd_t dfd, istr_t path, int mode, errhand_t hand = err_log)
  ;





int mknodat(fd_t dfd, istr_t path, int mode, unsigned dev, errhand_t hand = err_log)
  ;





int fchownat(fd_t dfd, istr_t path, uid_t user, gid_t group, int flag, errhand_t hand = err_log)
  ;





int futimesat(fd_t dfd, istr_t path, timeval_p utimes, errhand_t hand = err_log)
  ;





int newfstatat(fd_t dfd, istr_t path, stat_p statbuf, int flag, errhand_t hand = err_log)
  ;





int unlinkat(fd_t dfd, istr_t path, int flag, errhand_t hand = err_log)
  ;





int renameat(fd_t oldfd, istr_t opath, fd_t newfd, istr_t npath, errhand_t hand = err_log)
  ;





int linkat(fd_t oldfd, istr_t opath, fd_t newfd, istr_t npath, int flags, errhand_t hand = err_log)
  ;





int symlinkat(istr_t opath, fd_t newfd, istr_t npath, errhand_t hand = err_log)
  ;





int readlinkat(fd_t dfd, istr_t path, ostr_t buf, int bufsiz, errhand_t hand = err_log)
  ;





int fchmodat(fd_t dfd, istr_t path, mode_t mode, errhand_t hand = err_log)
  ;





int faccessat(fd_t dfd, istr_t path, int mode, errhand_t hand = err_log)
  ;





int pselect6(int n, fdset_p inp, fdset_p outp, fdset_p exp, timespec_p tsp, void_p sig, errhand_t hand = err_log)
  ;





int ppoll(pollfd_p ufds, unsigned nfds, timespec_p tsp, const sigset_p sigmask, size_t sigsetsize, errhand_t hand = err_log)
  ;





int unshare(int unshare_flags, errhand_t hand = err_log)
  ;





int set_robust_list(robust_list_head_p head, size_t len, errhand_t hand = err_log)
  ;





int get_robust_list(int pid, robust_list_head_p head_ptr, size_p len_ptr, errhand_t hand = err_log)
  ;





int splice(int fd_in, off_p off_in, int fd_out, off_p off_out, size_t len, unsigned flags, errhand_t hand = err_log)
  ;





int tee(int fdin, int fdout, size_t len, unsigned flags, errhand_t hand = err_log)
  ;





int sync_file_range(fd_t fd, off_t offset, off_t bytes, long flags, errhand_t hand = err_log)
  ;





int vmsplice(fd_t fd, iovec_p iov, uint64_t nr_segs, unsigned flags, errhand_t hand = err_log)
  ;





int move_pages(pid_t pid, uint64_t nr_pages, void_p pages, int32_p nodes, int32_p status, int flags, errhand_t hand = err_log)
  ;





int utimensat(fd_t dfd, istr_t path, timespec_p utimes, int flags, errhand_t hand = err_log)
  ;





int epoll_pwait(int epfd, epoll_event_p events, int maxevents, int timeout, const sigset_p sigmask, size_t sigsetsize, errhand_t hand = err_log)
  ;





int signalfd(int ufd, sigset_p user_mask, size_t sizemask, errhand_t hand = err_log)
  ;





int timerfd_create(int clockid, int flags, errhand_t hand = err_log)
  ;





int eventfd(unsigned count, errhand_t hand = err_log)
  ;





int fallocate(fd_t fd, long mode, off_t offset, off_t len, errhand_t hand = err_log)
  ;





int timerfd_settime(int ufd, int flags, itimerspec_p utmr, itimerspec_p otmr, errhand_t hand = err_log)
  ;





int timerfd_gettime(int ufd, itimerspec_p otmr, errhand_t hand = err_log)
  ;





int accept4(fd_t fd, sockaddr_p upeer_sockaddr, int32_p upeer_addrlen, int flags, errhand_t hand = err_log)
  ;





int signalfd4(int ufd, sigset_p user_mask, size_t sizemask, int flags, errhand_t hand = err_log)
  ;





int eventfd2(unsigned count, int flags, errhand_t hand = err_log)
  ;





int epoll_create1(int flags, errhand_t hand = err_log)
  ;





int dup3(fd_t oldfd, fd_t newfd, int flags, errhand_t hand = err_log)
  ;





int pipe2(fd_p filedes, int flags, errhand_t hand = err_log)
  ;





int inotify_init1(int flags, errhand_t hand = err_log)
  ;





int preadv(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h, errhand_t hand = err_log)
  ;





int pwritev(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h, errhand_t hand = err_log)
  ;





int rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_p uinfo, errhand_t hand = err_log)
  ;





int perf_event_open(perf_event_attr_p attr_uptr, pid_t pid, int cpu, int group_fd, uint64_t flags, errhand_t hand = err_log)
  ;





int recvmmsg(fd_t fd, msghdr_p mmsg, unsigned vlen, unsigned flags, timespec_p timeout, errhand_t hand = err_log)
  ;





int fanotify_init(unsigned flags, unsigned event_f_flags, errhand_t hand = err_log)
  ;





int fanotify_mark(long fanotify_fd, long flags, uint64_t mask, fd_t dfd, istr_t path, errhand_t hand = err_log)
  ;





int prlimit64(pid_t pid, unsigned resource, rlimit64_p new_rlim, rlimit64_p old_rlim, errhand_t hand = err_log)
  ;





int name_to_handle_at(fd_t dfd, istr_t name, file_handle_p handle, int32_p mnt_id, int flag, errhand_t hand = err_log)
  ;





int open_by_handle_at(fd_t dfd, istr_t name, file_handle_p handle, int32_p mnt_id, int flags, errhand_t hand = err_log)
  ;





int clock_adjtime(clockid_t which_clock, timex_p tx, errhand_t hand = err_log)
  ;





int syncfs(fd_t fd, errhand_t hand = err_log)
  ;





int sendmmsg(fd_t fd, msghdr_p mmsg, unsigned vlen, unsigned flags, errhand_t hand = err_log)
  ;





int setns(fd_t fd, int nstype, errhand_t hand = err_log)
  ;





int getcpu(uint32_p cpup, uint32_p nodep, errhand_t hand = err_log)
  ;





int process_vm_readv(pid_t pid, iovec_p lvec, uint64_t liovcnt, iovec_p rvec, uint64_t riovcnt, uint64_t flags, errhand_t hand = err_log)
  ;





int process_vm_writev(pid_t pid, iovec_p lvec, uint64_t liovcnt, iovec_p rvec, uint64_t riovcnt, uint64_t flags, errhand_t hand = err_log)
  ;





int kcmp(pid_t pid1, pid_t pid2, int type, uint64_t idx1, uint64_t idx2, errhand_t hand = err_log)
  ;





int finit_module(fd_t fd, istr_t uargs, int flags, errhand_t hand = err_log)
  ;





int sched_setattr(pid_t pid, sched_attr_p attr, unsigned flags, errhand_t hand = err_log)
  ;





int sched_getattr(pid_t pid, sched_attr_p attr, unsigned size, unsigned flags, errhand_t hand = err_log)
  ;





int renameat2(int olddfd, istr_t opath, int newdfd, istr_t npath, unsigned flags, errhand_t hand = err_log)
  ;





int seccomp(unsigned op, unsigned flags, istr_t uargs, errhand_t hand = err_log)
  ;





int getrandom(ostr_t buf, size_t count, unsigned flags, errhand_t hand = err_log)
  ;





int memfd_create(istr_t uname_ptr, unsigned flags, errhand_t hand = err_log)
  ;





int kexec_file_load(int kernel_fd, int initrd_fd, size_t cmdline_len, istr_t cmdline_ptr, uint64_t flags, errhand_t hand = err_log)
  ;





int bpf(int cmd, bpf_attr_p attr, unsigned size, errhand_t hand = err_log)
  ;





int execveat(fd_t dfd, istr_t path, istr_v argv, istr_v envp, int flags, errhand_t hand = err_log)
  ;





int userfaultfd(int flags, errhand_t hand = err_log)
  ;





int membarrier(int cmd, int flags, errhand_t hand = err_log)
  ;





int mlock2(uint64_t start, size_t len, int flags, errhand_t hand = err_log)
  ;





int copy_file_range(fd_t fd_in, off_p off_in, fd_t fd_out, off_p off_out, size_t len, unsigned flags, errhand_t hand = err_log)
  ;





int preadv2(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h, int flags, errhand_t hand = err_log)
  ;





int pwritev2(fd_t fd, iovec_p vec, uint64_t vlen, uint64_t pos_l, uint64_t pos_h, int flags, errhand_t hand = err_log)
  ;



}
// #  100 "inc/syscall.hh" 2





namespace fmt {
  struct fmt_t;
};
namespace sys {
  inline fd_t open(istr_t path, open_flags flags, mode_t mode, errhand_t hand=err_log) {
    return open(path,flags,mode,hand);
  };
  inline fd_t open(istr_t path, open_flags flags, errhand_t hand=err_log) {
    return open(path,flags,mode_t(0),hand);
  };





  inline ssize_t write(fd_t fd, const c_str &str, errhand_t hand) {
    iovec vec = (iovec)str;
    return write(fd,str,hand);
  };
  inline ssize_t write(fd_t fd, const iovec &vec, errhand_t hand) {
    return write(fd,(const char*)vec.iov_base,vec.iov_len,hand);
  };
  inline ssize_t write(fd_t fd, const char *buf, const char *end, errhand_t hand=err_log)
  {
    iovec vec;
    vec.iov_base=(void*)buf;
    vec.iov_len=ssize_t(end-buf);
    return write(fd,vec,hand);
  };
  ssize_t write(fd_t fd, const fmt::fmt_t &fmt, errhand_t hand = err_log);
  inline ssize_t write(fd_t fd, const char* buf, errhand_t hand=err_log)
  {
    const char* end= buf;
    while(*end)
      ++end;
    return write(fd, iovec(buf, end), hand);
  }
  inline ssize_t full_write(fd_t fd, const char* const beg, size_t len)
    __attribute__((__always_inline__));
  inline const char* full_write(int fd,
                                const char* const beg,
                                const char* end)
    __attribute__((__always_inline__));

  inline const char* full_write(int fd,
                                const char* const beg,
                                const char* end,
                                errhand_t hand=err_fatal
                                )
  {
    const char* pos= beg;
    while(pos != end)
    {
      ssize_t res= write(fd, pos, end-pos, hand);
      pos+= res;
    }
    return pos;
  }
  inline ssize_t full_write(fd_t fd, const char* const beg, size_t len,
      errhand_t hand=err_fatal)
  {
    return full_write(fd, beg, beg + len, hand=err_fatal) - beg;
  }
  ssize_t write(fd_t fd, const c_str &buf, errhand_t hand = err_log);
  void assert_fail(const char *, const char *, unsigned) __attribute__((__noreturn__));
  bool isatty(fd_t fd);
  void drop_ctty(fd_t fd, errhand_t hand=err_log);
  int system(const char *cmd);
}

// # define L(x) x, sizeof(x) - 1


namespace std
{
  void abort() __attribute__((__noreturn__));
  inline void abort()
  {
    do
    {
      asm("int3");
    } while(true);
  }
  void terminate() noexcept __attribute__((__noreturn__));
  enum nothrow_t
  {
  };
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();


}

namespace sys {
  struct termios;
  struct winsize;
  int login_tty(fd_t fd);
  fd_t openpty(fd_t &mpty, fd_t &spty, const termios &term, const winsize &size);
  pid_t forkpty(fd_t &mpty, fd_t &spty, const termios &term, const winsize &size);
  fd_t openpt(int flags, errhand_t=err_log);
  int unlockpt(fd_t fd,bool ilock,errhand_t hand=err_log);
  int grantpt(fd_t fd,errhand_t hand=err_log);
  fd_t getpt_peer(fd_t fd,open_flags flags,errhand_t hand=err_log);
};

extern "C" {
  void *memcpy(void *d, void *s, size_t n);
  void memset(void *b, char v, size_t n);
  size_t strlen(const char *);
}
// # define assert(x) do{ if(!(x)){ sys::assert_fail(#x,__FILE__,__LINE__); }} while(0)




// #  1 "inc/bitset.hh" 1
       

// #  1 "inc/fmt.hh" 1
       

namespace sys {
  struct timeval_t;
};
namespace fmt {
  struct int_t {
    unsigned long abs;
    bool neg;
    static unsigned long get_abs(long val)
    {
      return val<0?-val:val;
    };
    static bool get_neg(long val) {
      return val<0;
    };
    int_t(unsigned long abs)
      :abs(abs),neg(false)
    {
    }
    int_t(long val)
      :abs(get_abs(val)),neg(get_neg(val))
    {
    }
    int_t(unsigned abs)
      :abs(abs),neg(false)
    {
    }
    int_t(int val)
      :abs(get_abs(val)),neg(get_neg(val))
    {
    }
    int_t(unsigned short abs)
      :abs(abs),neg(false)
    {
    }
    int_t(short val)
      :abs(get_abs(val)),neg(get_neg(val))
    {
    }
    int_t(unsigned char abs)
      :abs(abs),neg(false)
    {
    }
    int_t(char val)
      :abs(get_abs(val)),neg(get_neg(val))
    {
    }
  };

  struct fmt_t
  {
    struct body_t {
      char buf[68];
      char nul[1];
      char off;
      char len;
      body_t()
      {
      };
      ~body_t() {
      };
    } body;
    void format(int_t wrap, int base, int width, char fill);
    void format(float val, int width, int prec=6);
    void format(void *ptr, int width=16);
    fmt_t(unsigned long val,int base=10, int width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(long val,int base=10, int width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(unsigned int val,int base=10, int width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(int val,int base=10, int width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(unsigned short val,int base=10, int width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(short val,int base=10, int width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(unsigned char val,char base=10, char width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(char val,char base=10, char width=1, char fill='0')
    {
      format(val,base,width,fill);
    };
    fmt_t(float f,int width=0, int prec=6, char fill=' ')
    {
      format(f,width,prec);
    };
    fmt_t(void *ptr, int width=16)
    {
      format(ptr,width);
    };
    fmt_t(sys::errno_t errno);
    fmt_t(bool val);
    fmt_t(const timeval_t &val);
    size_t len() {
      return body.len;
    };
    operator iovec() const {
      return { (void*)(body.buf+body.off), (size_t)(body.len) };
    };
    static constexpr const char digits[]="0123456789abcdef";
  };
  inline bool isspace(int i){
    switch(i){
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 32:
        return true;
      default:
        return false;
    }
  };
  inline uint64_t atoi(const char *pos){
    uint64_t res=0;
    while(isspace(*pos))
      pos++;
    while(*pos>='0' && *pos<='9') {
      res*=10;
      res+=(*pos-'0');
      ++pos;
    };
    return res;
  }
}
// #  4 "inc/bitset.hh" 2
namespace collect {
  template <size_t N>
    struct bitset_t {
      typedef uint16_t word_t;
      static constexpr size_t BITS = N;
      static constexpr size_t WORD_BITS = sizeof(word_t)*8;
      static constexpr size_t WORDS = (N + WORD_BITS - 1) / WORD_BITS;

      uint64_t vals[WORDS] = {};

      void check_bit(size_t bit)const;
      constexpr void set(size_t bit) {
        check_bit(bit);
        vals[bit / WORD_BITS] |= (word_t(1) << (bit % WORD_BITS));
      }

      constexpr void clear(size_t bit) {
        check_bit(bit);
        vals[bit / WORD_BITS] &= ~(word_t(1) << (bit % WORD_BITS));
      }
      constexpr bool is_set(size_t bit) const {
        return test(bit);
      };
      constexpr bool get(size_t bit) const {
        return test(bit);
      };
      constexpr bool test(size_t bit) const {
        check_bit(bit);
        return vals[bit / WORD_BITS] & (word_t(1) << (bit % WORD_BITS));
      }

      constexpr void reset() {
        for (size_t i = 0; i < WORDS; ++i) {
          vals[i] = 0;
        }
      }

      constexpr bool any() const {
        for (size_t i = 0; i < WORDS; ++i) {
          if (vals[i] != 0) return true;
        }
        return false;
      }

      constexpr bool none() const {
        return !any();
      }

      int find_highest() const {
        for (size_t i = WORDS; i-- > 0;) {
          if (vals[i] != 0) {

            int leading_zeros = __builtin_clzll(vals[i]);
            int bit_index = 63 - leading_zeros;
// #  66 "inc/bitset.hh"
            return int(i * WORD_BITS + bit_index);
          }
        }
        return -1;
      }
      char* format(char* b, char* e, char zero_char = '0', char one_char = '1') const {
        if ((e - b) > ptrdiff_t(N)) {

          for (size_t i = 0; i < N; ++i) {
            *b++ = test(N - 1 - i) ? one_char : zero_char;
          }

          *b = '\0';
          return b;
        } else {
          *b=0;
          return 0;
        };
      }
    };
}
namespace sys {
  struct fdset_t : public collect::bitset_t<32> {
    fdset_t select(timeval_t);
    fdset_t( fd_t fd1=fd_t(), fd_t fd2=fd_t(), fd_t fd3=fd_t(),
        fd_t fd4=fd_t(), fd_t fd5=fd_t(), fd_t fd6=fd_t(),
        fd_t fd7=fd_t(), fd_t fd8=fd_t(), fd_t fd9=fd_t()
        );

  };
};
// #  217 "inc/syscall.hh" 2
// #  2 "lib/errno.cc" 2




using fmt::fmt_t;
struct set_bool {
  bool &val;
  set_bool(bool &val)
    : val(val)
  {
    val=true;
  }
  ~set_bool()
  {
    val=false;
  };
};
namespace itr {
void fuck_off(int res, char const *msg) {
  sys::die(res,msg);
};
};
void sys::err_ignore(sys::errno_t err)
{
};
void sys::err_log(sys::errno_t err)
{
  static bool recurse=false;
  if(recurse)
    return;
  set_bool setter(recurse);
  sys::write(2,"setting error to: ");
  sys::write(2,fmt_t((long)err));
  sys::write(2,"\n\n");
};

void sys::err_fatal(errno_t err) {
  sys::write(2,"FROM: ");
  sys::write(2,fmt_t(getpid()));
  sys::write(2,"  FATAL ERROR: ");
  sys::write(2,fmt_t(err));
  sys::write(2,"\n");
  sys::write(2,strerror(err),(errhand_t)0);
  sys::write(2,"\n");
  pexit(5,"err_fatal");
  std::abort();
  kill(getpid(),9);
};
void sys::set_errno(errno_t err, errhand_t hand)
{
  if(err<0 && err>-4096) {
    err=(errno_t)-err;
  } else if (err>uint64_t(-4096)) {
    err=(errno_t)-err;
  };
  errno=err;
  hand(err);
}
namespace sys {
  void throw_errno(errno_t err);
};
void sys::throw_errno(errno_t err){
  sys::set_errno(err);
  char buf[1023]="setting error to: ";
  char *pos=buf+itr::len(buf);
  char *end=buf+sizeof(buf)-1;
  *--end=0;
  pos=itr::copy(pos,end,fmt_t(err));
  pos=itr::copy(pos,end," ( ");
  pos=itr::copy(pos,end,sys::strerror(sys::errno));
  pos=itr::copy(pos,end," )\n");
  exit(-1);
};
namespace sys {
  inline bool err_retry_on_transient(errno_t err) {
    static collect::bitset_t<128> transient = {
      EINTR,
      EAGAIN,
      EWOULDBLOCK,
    };
    return transient.is_set(err);
  }
  void err_die_if_stdin_tty(sys::errno_t err) {
    if(isatty(0))
      pexit(3,"stdin is a tty, but can't open /dev/tty");
  }
  errno_t errno;
  void perror(const char *msg)
  {
    static const char *null="";
    perror(null,msg);
  };
  void die(int err, const char *msg1, const char *msg2)
  {
    perror(msg1,msg2);
    exit(err);
  };
  void die(int err, const char *msg)
  {
    write(2,msg);
    exit(err);
  };
  void die(const char *msg){
    die(1,msg);
  };
  void pexit(int err, const char *msg1, const char *msg2)
  {
    write(2,msg1);
    write(2,msg2);
    exit(err);
  };
  void pexit(int err, const char *msg)
  {
    perror(msg);
    exit(err);
  };
  void perror(const char *msg1, const char *msg2)
  {
    if(msg1) {
      write(2,msg1);
      write(2,":");
    };
    if(msg2) {
      write(2,msg2);
      write(2,":");
    };
    write(2,fmt_t(errno));
    write(2,"  --  ",6);
    write(2,strerror(errno));
  };
  void pexit(const char *msg1, const char *msg2)
  {
    perror(msg1,msg2);
    exit(1);
  };
  void assert_fail(const char *cond, const char *file, unsigned line){
    write(2,file);
    write(2,":");
    write(2,fmt_t(line));
    write(2,": assertion (");
    write(2,cond);
    write(2,") failed");
    exit(1);
  };
};
